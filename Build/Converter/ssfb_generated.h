// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
#define FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_

#include "flatbuffers/flatbuffers.h"

namespace ss {
namespace ssfb {

struct EffectParticleInfiniteEmitEnabled;

struct EffectParticleTurnToDirectionEnabled;

struct EffectParticlePointGravity;

struct EffectParticleElementTransSize;

struct EffectParticleElementSize;

struct EffectParticleElementAlphaFade;

struct EffectParticleElementTransColor;

struct EffectParticleElementInitColor;

struct EffectParticleElementTangentialAcceleration;

struct EffectParticleElementTransSpeed;

struct EffectParticleElementRotationTrans;

struct EffectParticleElementRotation;

struct EffectParticleElementPosition;

struct EffectParticleElementGravity;

struct EffectParticleElementDelay;

struct EffectParticleElementRndSeedChange;

struct EffectParticleElementBasic;

struct EffectNode;
struct EffectNodeT;

struct EffectFile;
struct EffectFileT;

struct CellMap;
struct CellMapT;

struct Cell;
struct CellT;

struct MeshDataUV;
struct MeshDataUVT;

struct MeshDataIndices;
struct MeshDataIndicesT;

struct PartState;
struct PartStateT;

struct FrameDataIndex;
struct FrameDataIndexT;

struct UserDataInteger;

struct UserDataRect;

struct UserDataPoint;

struct UserDataString;
struct UserDataStringT;

struct UserDataItem;
struct UserDataItemT;

struct UserDataPerFrame;
struct UserDataPerFrameT;

struct LabelDataItem;
struct LabelDataItemT;

struct AnimationData;
struct AnimationDataT;

struct AnimationInitialData;
struct AnimationInitialDataT;

struct PartData;
struct PartDataT;

struct AnimePackData;
struct AnimePackDataT;

struct ProjectData;
struct ProjectDataT;

bool operator==(const EffectParticleInfiniteEmitEnabled &lhs, const EffectParticleInfiniteEmitEnabled &rhs);
bool operator!=(const EffectParticleInfiniteEmitEnabled &lhs, const EffectParticleInfiniteEmitEnabled &rhs);
bool operator==(const EffectParticleTurnToDirectionEnabled &lhs, const EffectParticleTurnToDirectionEnabled &rhs);
bool operator!=(const EffectParticleTurnToDirectionEnabled &lhs, const EffectParticleTurnToDirectionEnabled &rhs);
bool operator==(const EffectParticlePointGravity &lhs, const EffectParticlePointGravity &rhs);
bool operator!=(const EffectParticlePointGravity &lhs, const EffectParticlePointGravity &rhs);
bool operator==(const EffectParticleElementTransSize &lhs, const EffectParticleElementTransSize &rhs);
bool operator!=(const EffectParticleElementTransSize &lhs, const EffectParticleElementTransSize &rhs);
bool operator==(const EffectParticleElementSize &lhs, const EffectParticleElementSize &rhs);
bool operator!=(const EffectParticleElementSize &lhs, const EffectParticleElementSize &rhs);
bool operator==(const EffectParticleElementAlphaFade &lhs, const EffectParticleElementAlphaFade &rhs);
bool operator!=(const EffectParticleElementAlphaFade &lhs, const EffectParticleElementAlphaFade &rhs);
bool operator==(const EffectParticleElementTransColor &lhs, const EffectParticleElementTransColor &rhs);
bool operator!=(const EffectParticleElementTransColor &lhs, const EffectParticleElementTransColor &rhs);
bool operator==(const EffectParticleElementInitColor &lhs, const EffectParticleElementInitColor &rhs);
bool operator!=(const EffectParticleElementInitColor &lhs, const EffectParticleElementInitColor &rhs);
bool operator==(const EffectParticleElementTangentialAcceleration &lhs, const EffectParticleElementTangentialAcceleration &rhs);
bool operator!=(const EffectParticleElementTangentialAcceleration &lhs, const EffectParticleElementTangentialAcceleration &rhs);
bool operator==(const EffectParticleElementTransSpeed &lhs, const EffectParticleElementTransSpeed &rhs);
bool operator!=(const EffectParticleElementTransSpeed &lhs, const EffectParticleElementTransSpeed &rhs);
bool operator==(const EffectParticleElementRotationTrans &lhs, const EffectParticleElementRotationTrans &rhs);
bool operator!=(const EffectParticleElementRotationTrans &lhs, const EffectParticleElementRotationTrans &rhs);
bool operator==(const EffectParticleElementRotation &lhs, const EffectParticleElementRotation &rhs);
bool operator!=(const EffectParticleElementRotation &lhs, const EffectParticleElementRotation &rhs);
bool operator==(const EffectParticleElementPosition &lhs, const EffectParticleElementPosition &rhs);
bool operator!=(const EffectParticleElementPosition &lhs, const EffectParticleElementPosition &rhs);
bool operator==(const EffectParticleElementGravity &lhs, const EffectParticleElementGravity &rhs);
bool operator!=(const EffectParticleElementGravity &lhs, const EffectParticleElementGravity &rhs);
bool operator==(const EffectParticleElementDelay &lhs, const EffectParticleElementDelay &rhs);
bool operator!=(const EffectParticleElementDelay &lhs, const EffectParticleElementDelay &rhs);
bool operator==(const EffectParticleElementRndSeedChange &lhs, const EffectParticleElementRndSeedChange &rhs);
bool operator!=(const EffectParticleElementRndSeedChange &lhs, const EffectParticleElementRndSeedChange &rhs);
bool operator==(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs);
bool operator!=(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs);
bool operator==(const EffectNodeT &lhs, const EffectNodeT &rhs);
bool operator!=(const EffectNodeT &lhs, const EffectNodeT &rhs);
bool operator==(const EffectFileT &lhs, const EffectFileT &rhs);
bool operator!=(const EffectFileT &lhs, const EffectFileT &rhs);
bool operator==(const CellMapT &lhs, const CellMapT &rhs);
bool operator!=(const CellMapT &lhs, const CellMapT &rhs);
bool operator==(const CellT &lhs, const CellT &rhs);
bool operator!=(const CellT &lhs, const CellT &rhs);
bool operator==(const MeshDataUVT &lhs, const MeshDataUVT &rhs);
bool operator!=(const MeshDataUVT &lhs, const MeshDataUVT &rhs);
bool operator==(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs);
bool operator!=(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs);
bool operator==(const PartStateT &lhs, const PartStateT &rhs);
bool operator!=(const PartStateT &lhs, const PartStateT &rhs);
bool operator==(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs);
bool operator!=(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs);
bool operator==(const UserDataInteger &lhs, const UserDataInteger &rhs);
bool operator!=(const UserDataInteger &lhs, const UserDataInteger &rhs);
bool operator==(const UserDataRect &lhs, const UserDataRect &rhs);
bool operator!=(const UserDataRect &lhs, const UserDataRect &rhs);
bool operator==(const UserDataPoint &lhs, const UserDataPoint &rhs);
bool operator!=(const UserDataPoint &lhs, const UserDataPoint &rhs);
bool operator==(const UserDataStringT &lhs, const UserDataStringT &rhs);
bool operator!=(const UserDataStringT &lhs, const UserDataStringT &rhs);
bool operator==(const UserDataItemT &lhs, const UserDataItemT &rhs);
bool operator!=(const UserDataItemT &lhs, const UserDataItemT &rhs);
bool operator==(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs);
bool operator!=(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs);
bool operator==(const LabelDataItemT &lhs, const LabelDataItemT &rhs);
bool operator!=(const LabelDataItemT &lhs, const LabelDataItemT &rhs);
bool operator==(const AnimationDataT &lhs, const AnimationDataT &rhs);
bool operator!=(const AnimationDataT &lhs, const AnimationDataT &rhs);
bool operator==(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs);
bool operator!=(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs);
bool operator==(const PartDataT &lhs, const PartDataT &rhs);
bool operator!=(const PartDataT &lhs, const PartDataT &rhs);
bool operator==(const AnimePackDataT &lhs, const AnimePackDataT &rhs);
bool operator!=(const AnimePackDataT &lhs, const AnimePackDataT &rhs);
bool operator==(const ProjectDataT &lhs, const ProjectDataT &rhs);
bool operator!=(const ProjectDataT &lhs, const ProjectDataT &rhs);

enum SsPartType {
  SsPartType_Invalid = -1,
  SsPartType_Nulltype = 0,
  SsPartType_Normal = 1,
  SsPartType_Text = 2,
  SsPartType_Instance = 3,
  SsPartType_Armature = 4,
  SsPartType_Effect = 5,
  SsPartType_Mesh = 6,
  SsPartType_Movenode = 7,
  SsPartType_Constraint = 8,
  SsPartType_Mask = 9,
  SsPartType_Joint = 10,
  SsPartType_Bonepoint = 11,
  SsPartType_MIN = SsPartType_Invalid,
  SsPartType_MAX = SsPartType_Bonepoint
};

inline const SsPartType (&EnumValuesSsPartType())[13] {
  static const SsPartType values[] = {
    SsPartType_Invalid,
    SsPartType_Nulltype,
    SsPartType_Normal,
    SsPartType_Text,
    SsPartType_Instance,
    SsPartType_Armature,
    SsPartType_Effect,
    SsPartType_Mesh,
    SsPartType_Movenode,
    SsPartType_Constraint,
    SsPartType_Mask,
    SsPartType_Joint,
    SsPartType_Bonepoint
  };
  return values;
}

inline const char * const *EnumNamesSsPartType() {
  static const char * const names[] = {
    "Invalid",
    "Nulltype",
    "Normal",
    "Text",
    "Instance",
    "Armature",
    "Effect",
    "Mesh",
    "Movenode",
    "Constraint",
    "Mask",
    "Joint",
    "Bonepoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameSsPartType(SsPartType e) {
  if (e < SsPartType_Invalid || e > SsPartType_Bonepoint) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(SsPartType_Invalid);
  return EnumNamesSsPartType()[index];
}

enum PartFlag {
  PartFlag_Invisible = 1,
  PartFlag_FlipH = 2,
  PartFlag_FlipV = 4,
  PartFlag_CellIndex = 8,
  PartFlag_PositionX = 16,
  PartFlag_PositionY = 32,
  PartFlag_PositionZ = 64,
  PartFlag_PivotX = 128,
  PartFlag_PivotY = 256,
  PartFlag_RotationX = 512,
  PartFlag_RotationY = 1024,
  PartFlag_RotationnZ = 2048,
  PartFlag_ScaleX = 4096,
  PartFlag_ScaleY = 8192,
  PartFlag_LocalScaleX = 16384,
  PartFlag_LocalScaleY = 32768,
  PartFlag_Opacity = 65536,
  PartFlag_LocalOpacity = 131072,
  PartFlag_PartsColor = 262144,
  PartFlag_VertexTransform = 524288,
  PartFlag_SizeX = 1048576,
  PartFlag_SizeY = 2097152,
  PartFlag_UMove = 4194304,
  PartFlag_VMove = 8388608,
  PartFlag_UvRotation = 16777216,
  PartFlag_UScale = 33554432,
  PartFlag_VScale = 67108864,
  PartFlag_BoundingRadius = 134217728,
  PartFlag_Mask = 268435456,
  PartFlag_Priority = 536870912,
  PartFlag_InstanceKeyframe = 1073741824,
  PartFlag_EffectKeyframe = 2147483648,
  PartFlag_NONE = 0,
  PartFlag_ANY = 4294967295
};

inline const PartFlag (&EnumValuesPartFlag())[32] {
  static const PartFlag values[] = {
    PartFlag_Invisible,
    PartFlag_FlipH,
    PartFlag_FlipV,
    PartFlag_CellIndex,
    PartFlag_PositionX,
    PartFlag_PositionY,
    PartFlag_PositionZ,
    PartFlag_PivotX,
    PartFlag_PivotY,
    PartFlag_RotationX,
    PartFlag_RotationY,
    PartFlag_RotationnZ,
    PartFlag_ScaleX,
    PartFlag_ScaleY,
    PartFlag_LocalScaleX,
    PartFlag_LocalScaleY,
    PartFlag_Opacity,
    PartFlag_LocalOpacity,
    PartFlag_PartsColor,
    PartFlag_VertexTransform,
    PartFlag_SizeX,
    PartFlag_SizeY,
    PartFlag_UMove,
    PartFlag_VMove,
    PartFlag_UvRotation,
    PartFlag_UScale,
    PartFlag_VScale,
    PartFlag_BoundingRadius,
    PartFlag_Mask,
    PartFlag_Priority,
    PartFlag_InstanceKeyframe,
    PartFlag_EffectKeyframe
  };
  return values;
}

inline const char *EnumNamePartFlag(PartFlag e) {
  switch (e) {
    case PartFlag_Invisible: return "Invisible";
    case PartFlag_FlipH: return "FlipH";
    case PartFlag_FlipV: return "FlipV";
    case PartFlag_CellIndex: return "CellIndex";
    case PartFlag_PositionX: return "PositionX";
    case PartFlag_PositionY: return "PositionY";
    case PartFlag_PositionZ: return "PositionZ";
    case PartFlag_PivotX: return "PivotX";
    case PartFlag_PivotY: return "PivotY";
    case PartFlag_RotationX: return "RotationX";
    case PartFlag_RotationY: return "RotationY";
    case PartFlag_RotationnZ: return "RotationnZ";
    case PartFlag_ScaleX: return "ScaleX";
    case PartFlag_ScaleY: return "ScaleY";
    case PartFlag_LocalScaleX: return "LocalScaleX";
    case PartFlag_LocalScaleY: return "LocalScaleY";
    case PartFlag_Opacity: return "Opacity";
    case PartFlag_LocalOpacity: return "LocalOpacity";
    case PartFlag_PartsColor: return "PartsColor";
    case PartFlag_VertexTransform: return "VertexTransform";
    case PartFlag_SizeX: return "SizeX";
    case PartFlag_SizeY: return "SizeY";
    case PartFlag_UMove: return "UMove";
    case PartFlag_VMove: return "VMove";
    case PartFlag_UvRotation: return "UvRotation";
    case PartFlag_UScale: return "UScale";
    case PartFlag_VScale: return "VScale";
    case PartFlag_BoundingRadius: return "BoundingRadius";
    case PartFlag_Mask: return "Mask";
    case PartFlag_Priority: return "Priority";
    case PartFlag_InstanceKeyframe: return "InstanceKeyframe";
    case PartFlag_EffectKeyframe: return "EffectKeyframe";
    default: return "";
  }
}

enum PartFlag2 {
  PartFlag2_MeshData = 1,
  PartFlag2_NONE = 0,
  PartFlag2_ANY = 1
};

inline const PartFlag2 (&EnumValuesPartFlag2())[1] {
  static const PartFlag2 values[] = {
    PartFlag2_MeshData
  };
  return values;
}

inline const char * const *EnumNamesPartFlag2() {
  static const char * const names[] = {
    "MeshData",
    nullptr
  };
  return names;
}

inline const char *EnumNamePartFlag2(PartFlag2 e) {
  if (e < PartFlag2_MeshData || e > PartFlag2_MeshData) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(PartFlag2_MeshData);
  return EnumNamesPartFlag2()[index];
}

enum VertexFlag {
  VertexFlag_LT = 1,
  VertexFlag_RT = 2,
  VertexFlag_LB = 4,
  VertexFlag_RB = 8,
  VertexFlag_ONE = 16,
  VertexFlag_NONE = 0,
  VertexFlag_ANY = 31
};

inline const VertexFlag (&EnumValuesVertexFlag())[5] {
  static const VertexFlag values[] = {
    VertexFlag_LT,
    VertexFlag_RT,
    VertexFlag_LB,
    VertexFlag_RB,
    VertexFlag_ONE
  };
  return values;
}

inline const char * const *EnumNamesVertexFlag() {
  static const char * const names[] = {
    "LT",
    "RT",
    "",
    "LB",
    "",
    "",
    "",
    "RB",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexFlag(VertexFlag e) {
  if (e < VertexFlag_LT || e > VertexFlag_ONE) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(VertexFlag_LT);
  return EnumNamesVertexFlag()[index];
}

enum InstanceLoopFlag {
  InstanceLoopFlag_Infinity = 1,
  InstanceLoopFlag_Reverse = 2,
  InstanceLoopFlag_PingPong = 4,
  InstanceLoopFlag_Independent = 8,
  InstanceLoopFlag_NONE = 0,
  InstanceLoopFlag_ANY = 15
};

inline const InstanceLoopFlag (&EnumValuesInstanceLoopFlag())[4] {
  static const InstanceLoopFlag values[] = {
    InstanceLoopFlag_Infinity,
    InstanceLoopFlag_Reverse,
    InstanceLoopFlag_PingPong,
    InstanceLoopFlag_Independent
  };
  return values;
}

inline const char * const *EnumNamesInstanceLoopFlag() {
  static const char * const names[] = {
    "Infinity",
    "Reverse",
    "",
    "PingPong",
    "",
    "",
    "",
    "Independent",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstanceLoopFlag(InstanceLoopFlag e) {
  if (e < InstanceLoopFlag_Infinity || e > InstanceLoopFlag_Independent) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(InstanceLoopFlag_Infinity);
  return EnumNamesInstanceLoopFlag()[index];
}

enum UserDataFlag {
  UserDataFlag_Integer = 1,
  UserDataFlag_Rect = 2,
  UserDataFlag_Point = 4,
  UserDataFlag_String = 8,
  UserDataFlag_NONE = 0,
  UserDataFlag_ANY = 15
};

inline const UserDataFlag (&EnumValuesUserDataFlag())[4] {
  static const UserDataFlag values[] = {
    UserDataFlag_Integer,
    UserDataFlag_Rect,
    UserDataFlag_Point,
    UserDataFlag_String
  };
  return values;
}

inline const char * const *EnumNamesUserDataFlag() {
  static const char * const names[] = {
    "Integer",
    "Rect",
    "",
    "Point",
    "",
    "",
    "",
    "String",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserDataFlag(UserDataFlag e) {
  if (e < UserDataFlag_Integer || e > UserDataFlag_String) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(UserDataFlag_Integer);
  return EnumNamesUserDataFlag()[index];
}

enum EffectNodeType {
  EffectNodeType_Invalid = -1,
  EffectNodeType_Root = 0,
  EffectNodeType_Emitter = 1,
  EffectNodeType_Particle = 2,
  EffectNodeType_MIN = EffectNodeType_Invalid,
  EffectNodeType_MAX = EffectNodeType_Particle
};

inline const EffectNodeType (&EnumValuesEffectNodeType())[4] {
  static const EffectNodeType values[] = {
    EffectNodeType_Invalid,
    EffectNodeType_Root,
    EffectNodeType_Emitter,
    EffectNodeType_Particle
  };
  return values;
}

inline const char * const *EnumNamesEffectNodeType() {
  static const char * const names[] = {
    "Invalid",
    "Root",
    "Emitter",
    "Particle",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectNodeType(EffectNodeType e) {
  if (e < EffectNodeType_Invalid || e > EffectNodeType_Particle) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(EffectNodeType_Invalid);
  return EnumNamesEffectNodeType()[index];
}

enum EffectRenderBlendType {
  EffectRenderBlendType_Invalid = -1,
  EffectRenderBlendType_Mix = 0,
  EffectRenderBlendType_Add = 1,
  EffectRenderBlendType_MIN = EffectRenderBlendType_Invalid,
  EffectRenderBlendType_MAX = EffectRenderBlendType_Add
};

inline const EffectRenderBlendType (&EnumValuesEffectRenderBlendType())[3] {
  static const EffectRenderBlendType values[] = {
    EffectRenderBlendType_Invalid,
    EffectRenderBlendType_Mix,
    EffectRenderBlendType_Add
  };
  return values;
}

inline const char * const *EnumNamesEffectRenderBlendType() {
  static const char * const names[] = {
    "Invalid",
    "Mix",
    "Add",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectRenderBlendType(EffectRenderBlendType e) {
  if (e < EffectRenderBlendType_Invalid || e > EffectRenderBlendType_Add) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(EffectRenderBlendType_Invalid);
  return EnumNamesEffectRenderBlendType()[index];
}

enum EffectNodeBehavior {
  EffectNodeBehavior_NONE = 0,
  EffectNodeBehavior_EffectParticleElementBasic = 1,
  EffectNodeBehavior_EffectParticleElementRndSeedChange = 2,
  EffectNodeBehavior_EffectParticleElementDelay = 3,
  EffectNodeBehavior_EffectParticleElementGravity = 4,
  EffectNodeBehavior_EffectParticleElementPosition = 5,
  EffectNodeBehavior_EffectParticleElementRotation = 6,
  EffectNodeBehavior_EffectParticleElementRotationTrans = 7,
  EffectNodeBehavior_EffectParticleElementTransSpeed = 8,
  EffectNodeBehavior_EffectParticleElementTangentialAcceleration = 9,
  EffectNodeBehavior_EffectParticleElementInitColor = 10,
  EffectNodeBehavior_EffectParticleElementTransColor = 11,
  EffectNodeBehavior_EffectParticleElementAlphaFade = 12,
  EffectNodeBehavior_EffectParticleElementSize = 13,
  EffectNodeBehavior_EffectParticleElementTransSize = 14,
  EffectNodeBehavior_EffectParticlePointGravity = 15,
  EffectNodeBehavior_EffectParticleTurnToDirectionEnabled = 16,
  EffectNodeBehavior_EffectParticleInfiniteEmitEnabled = 17,
  EffectNodeBehavior_MIN = EffectNodeBehavior_NONE,
  EffectNodeBehavior_MAX = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
};

inline const EffectNodeBehavior (&EnumValuesEffectNodeBehavior())[18] {
  static const EffectNodeBehavior values[] = {
    EffectNodeBehavior_NONE,
    EffectNodeBehavior_EffectParticleElementBasic,
    EffectNodeBehavior_EffectParticleElementRndSeedChange,
    EffectNodeBehavior_EffectParticleElementDelay,
    EffectNodeBehavior_EffectParticleElementGravity,
    EffectNodeBehavior_EffectParticleElementPosition,
    EffectNodeBehavior_EffectParticleElementRotation,
    EffectNodeBehavior_EffectParticleElementRotationTrans,
    EffectNodeBehavior_EffectParticleElementTransSpeed,
    EffectNodeBehavior_EffectParticleElementTangentialAcceleration,
    EffectNodeBehavior_EffectParticleElementInitColor,
    EffectNodeBehavior_EffectParticleElementTransColor,
    EffectNodeBehavior_EffectParticleElementAlphaFade,
    EffectNodeBehavior_EffectParticleElementSize,
    EffectNodeBehavior_EffectParticleElementTransSize,
    EffectNodeBehavior_EffectParticlePointGravity,
    EffectNodeBehavior_EffectParticleTurnToDirectionEnabled,
    EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
  };
  return values;
}

inline const char * const *EnumNamesEffectNodeBehavior() {
  static const char * const names[] = {
    "NONE",
    "EffectParticleElementBasic",
    "EffectParticleElementRndSeedChange",
    "EffectParticleElementDelay",
    "EffectParticleElementGravity",
    "EffectParticleElementPosition",
    "EffectParticleElementRotation",
    "EffectParticleElementRotationTrans",
    "EffectParticleElementTransSpeed",
    "EffectParticleElementTangentialAcceleration",
    "EffectParticleElementInitColor",
    "EffectParticleElementTransColor",
    "EffectParticleElementAlphaFade",
    "EffectParticleElementSize",
    "EffectParticleElementTransSize",
    "EffectParticlePointGravity",
    "EffectParticleTurnToDirectionEnabled",
    "EffectParticleInfiniteEmitEnabled",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectNodeBehavior(EffectNodeBehavior e) {
  if (e < EffectNodeBehavior_NONE || e > EffectNodeBehavior_EffectParticleInfiniteEmitEnabled) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEffectNodeBehavior()[index];
}

template<typename T> struct EffectNodeBehaviorTraits {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_NONE;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementBasic> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementBasic;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRndSeedChange> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRndSeedChange;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementDelay> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementDelay;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementPosition> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementPosition;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotation> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotation;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotationTrans> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotationTrans;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSpeed> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSpeed;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTangentialAcceleration> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTangentialAcceleration;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementInitColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementInitColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementAlphaFade> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementAlphaFade;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticlePointGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticlePointGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleTurnToDirectionEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleTurnToDirectionEnabled;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleInfiniteEmitEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled;
};

struct EffectNodeBehaviorUnion {
  EffectNodeBehavior type;
  void *value;

  EffectNodeBehaviorUnion() : type(EffectNodeBehavior_NONE), value(nullptr) {}
  EffectNodeBehaviorUnion(EffectNodeBehaviorUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(EffectNodeBehavior_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EffectNodeBehaviorUnion(const EffectNodeBehaviorUnion &) FLATBUFFERS_NOEXCEPT;
  EffectNodeBehaviorUnion &operator=(const EffectNodeBehaviorUnion &u) FLATBUFFERS_NOEXCEPT
    { EffectNodeBehaviorUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EffectNodeBehaviorUnion &operator=(EffectNodeBehaviorUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EffectNodeBehaviorUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = EffectNodeBehaviorTraits<typename RT::TableType>::enum_value;
    if (type != EffectNodeBehavior_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, EffectNodeBehavior type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  EffectParticleElementBasic *AsEffectParticleElementBasic() {
    return type == EffectNodeBehavior_EffectParticleElementBasic ?
      reinterpret_cast<EffectParticleElementBasic *>(value) : nullptr;
  }
  const EffectParticleElementBasic *AsEffectParticleElementBasic() const {
    return type == EffectNodeBehavior_EffectParticleElementBasic ?
      reinterpret_cast<const EffectParticleElementBasic *>(value) : nullptr;
  }
  EffectParticleElementRndSeedChange *AsEffectParticleElementRndSeedChange() {
    return type == EffectNodeBehavior_EffectParticleElementRndSeedChange ?
      reinterpret_cast<EffectParticleElementRndSeedChange *>(value) : nullptr;
  }
  const EffectParticleElementRndSeedChange *AsEffectParticleElementRndSeedChange() const {
    return type == EffectNodeBehavior_EffectParticleElementRndSeedChange ?
      reinterpret_cast<const EffectParticleElementRndSeedChange *>(value) : nullptr;
  }
  EffectParticleElementDelay *AsEffectParticleElementDelay() {
    return type == EffectNodeBehavior_EffectParticleElementDelay ?
      reinterpret_cast<EffectParticleElementDelay *>(value) : nullptr;
  }
  const EffectParticleElementDelay *AsEffectParticleElementDelay() const {
    return type == EffectNodeBehavior_EffectParticleElementDelay ?
      reinterpret_cast<const EffectParticleElementDelay *>(value) : nullptr;
  }
  EffectParticleElementGravity *AsEffectParticleElementGravity() {
    return type == EffectNodeBehavior_EffectParticleElementGravity ?
      reinterpret_cast<EffectParticleElementGravity *>(value) : nullptr;
  }
  const EffectParticleElementGravity *AsEffectParticleElementGravity() const {
    return type == EffectNodeBehavior_EffectParticleElementGravity ?
      reinterpret_cast<const EffectParticleElementGravity *>(value) : nullptr;
  }
  EffectParticleElementPosition *AsEffectParticleElementPosition() {
    return type == EffectNodeBehavior_EffectParticleElementPosition ?
      reinterpret_cast<EffectParticleElementPosition *>(value) : nullptr;
  }
  const EffectParticleElementPosition *AsEffectParticleElementPosition() const {
    return type == EffectNodeBehavior_EffectParticleElementPosition ?
      reinterpret_cast<const EffectParticleElementPosition *>(value) : nullptr;
  }
  EffectParticleElementRotation *AsEffectParticleElementRotation() {
    return type == EffectNodeBehavior_EffectParticleElementRotation ?
      reinterpret_cast<EffectParticleElementRotation *>(value) : nullptr;
  }
  const EffectParticleElementRotation *AsEffectParticleElementRotation() const {
    return type == EffectNodeBehavior_EffectParticleElementRotation ?
      reinterpret_cast<const EffectParticleElementRotation *>(value) : nullptr;
  }
  EffectParticleElementRotationTrans *AsEffectParticleElementRotationTrans() {
    return type == EffectNodeBehavior_EffectParticleElementRotationTrans ?
      reinterpret_cast<EffectParticleElementRotationTrans *>(value) : nullptr;
  }
  const EffectParticleElementRotationTrans *AsEffectParticleElementRotationTrans() const {
    return type == EffectNodeBehavior_EffectParticleElementRotationTrans ?
      reinterpret_cast<const EffectParticleElementRotationTrans *>(value) : nullptr;
  }
  EffectParticleElementTransSpeed *AsEffectParticleElementTransSpeed() {
    return type == EffectNodeBehavior_EffectParticleElementTransSpeed ?
      reinterpret_cast<EffectParticleElementTransSpeed *>(value) : nullptr;
  }
  const EffectParticleElementTransSpeed *AsEffectParticleElementTransSpeed() const {
    return type == EffectNodeBehavior_EffectParticleElementTransSpeed ?
      reinterpret_cast<const EffectParticleElementTransSpeed *>(value) : nullptr;
  }
  EffectParticleElementTangentialAcceleration *AsEffectParticleElementTangentialAcceleration() {
    return type == EffectNodeBehavior_EffectParticleElementTangentialAcceleration ?
      reinterpret_cast<EffectParticleElementTangentialAcceleration *>(value) : nullptr;
  }
  const EffectParticleElementTangentialAcceleration *AsEffectParticleElementTangentialAcceleration() const {
    return type == EffectNodeBehavior_EffectParticleElementTangentialAcceleration ?
      reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(value) : nullptr;
  }
  EffectParticleElementInitColor *AsEffectParticleElementInitColor() {
    return type == EffectNodeBehavior_EffectParticleElementInitColor ?
      reinterpret_cast<EffectParticleElementInitColor *>(value) : nullptr;
  }
  const EffectParticleElementInitColor *AsEffectParticleElementInitColor() const {
    return type == EffectNodeBehavior_EffectParticleElementInitColor ?
      reinterpret_cast<const EffectParticleElementInitColor *>(value) : nullptr;
  }
  EffectParticleElementTransColor *AsEffectParticleElementTransColor() {
    return type == EffectNodeBehavior_EffectParticleElementTransColor ?
      reinterpret_cast<EffectParticleElementTransColor *>(value) : nullptr;
  }
  const EffectParticleElementTransColor *AsEffectParticleElementTransColor() const {
    return type == EffectNodeBehavior_EffectParticleElementTransColor ?
      reinterpret_cast<const EffectParticleElementTransColor *>(value) : nullptr;
  }
  EffectParticleElementAlphaFade *AsEffectParticleElementAlphaFade() {
    return type == EffectNodeBehavior_EffectParticleElementAlphaFade ?
      reinterpret_cast<EffectParticleElementAlphaFade *>(value) : nullptr;
  }
  const EffectParticleElementAlphaFade *AsEffectParticleElementAlphaFade() const {
    return type == EffectNodeBehavior_EffectParticleElementAlphaFade ?
      reinterpret_cast<const EffectParticleElementAlphaFade *>(value) : nullptr;
  }
  EffectParticleElementSize *AsEffectParticleElementSize() {
    return type == EffectNodeBehavior_EffectParticleElementSize ?
      reinterpret_cast<EffectParticleElementSize *>(value) : nullptr;
  }
  const EffectParticleElementSize *AsEffectParticleElementSize() const {
    return type == EffectNodeBehavior_EffectParticleElementSize ?
      reinterpret_cast<const EffectParticleElementSize *>(value) : nullptr;
  }
  EffectParticleElementTransSize *AsEffectParticleElementTransSize() {
    return type == EffectNodeBehavior_EffectParticleElementTransSize ?
      reinterpret_cast<EffectParticleElementTransSize *>(value) : nullptr;
  }
  const EffectParticleElementTransSize *AsEffectParticleElementTransSize() const {
    return type == EffectNodeBehavior_EffectParticleElementTransSize ?
      reinterpret_cast<const EffectParticleElementTransSize *>(value) : nullptr;
  }
  EffectParticlePointGravity *AsEffectParticlePointGravity() {
    return type == EffectNodeBehavior_EffectParticlePointGravity ?
      reinterpret_cast<EffectParticlePointGravity *>(value) : nullptr;
  }
  const EffectParticlePointGravity *AsEffectParticlePointGravity() const {
    return type == EffectNodeBehavior_EffectParticlePointGravity ?
      reinterpret_cast<const EffectParticlePointGravity *>(value) : nullptr;
  }
  EffectParticleTurnToDirectionEnabled *AsEffectParticleTurnToDirectionEnabled() {
    return type == EffectNodeBehavior_EffectParticleTurnToDirectionEnabled ?
      reinterpret_cast<EffectParticleTurnToDirectionEnabled *>(value) : nullptr;
  }
  const EffectParticleTurnToDirectionEnabled *AsEffectParticleTurnToDirectionEnabled() const {
    return type == EffectNodeBehavior_EffectParticleTurnToDirectionEnabled ?
      reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(value) : nullptr;
  }
  EffectParticleInfiniteEmitEnabled *AsEffectParticleInfiniteEmitEnabled() {
    return type == EffectNodeBehavior_EffectParticleInfiniteEmitEnabled ?
      reinterpret_cast<EffectParticleInfiniteEmitEnabled *>(value) : nullptr;
  }
  const EffectParticleInfiniteEmitEnabled *AsEffectParticleInfiniteEmitEnabled() const {
    return type == EffectNodeBehavior_EffectParticleInfiniteEmitEnabled ?
      reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(value) : nullptr;
  }
};


inline bool operator==(const EffectNodeBehaviorUnion &lhs, const EffectNodeBehaviorUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case EffectNodeBehavior_NONE: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementBasic: {
      return *(reinterpret_cast<const EffectParticleElementBasic *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementBasic *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      return *(reinterpret_cast<const EffectParticleElementRndSeedChange *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementRndSeedChange *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      return *(reinterpret_cast<const EffectParticleElementDelay *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementDelay *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      return *(reinterpret_cast<const EffectParticleElementGravity *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementGravity *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      return *(reinterpret_cast<const EffectParticleElementPosition *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementPosition *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      return *(reinterpret_cast<const EffectParticleElementRotation *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementRotation *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      return *(reinterpret_cast<const EffectParticleElementRotationTrans *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementRotationTrans *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      return *(reinterpret_cast<const EffectParticleElementTransSpeed *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTransSpeed *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      return *(reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      return *(reinterpret_cast<const EffectParticleElementInitColor *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementInitColor *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      return *(reinterpret_cast<const EffectParticleElementTransColor *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTransColor *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      return *(reinterpret_cast<const EffectParticleElementAlphaFade *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementAlphaFade *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      return *(reinterpret_cast<const EffectParticleElementSize *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementSize *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      return *(reinterpret_cast<const EffectParticleElementTransSize *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTransSize *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      return *(reinterpret_cast<const EffectParticlePointGravity *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticlePointGravity *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      return *(reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      return *(reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const EffectNodeBehaviorUnion &lhs, const EffectNodeBehaviorUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type);
bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum UserDataValue {
  UserDataValue_NONE = 0,
  UserDataValue_UserDataInteger = 1,
  UserDataValue_UserDataRect = 2,
  UserDataValue_UserDataPoint = 3,
  UserDataValue_UserDataString = 4,
  UserDataValue_MIN = UserDataValue_NONE,
  UserDataValue_MAX = UserDataValue_UserDataString
};

inline const UserDataValue (&EnumValuesUserDataValue())[5] {
  static const UserDataValue values[] = {
    UserDataValue_NONE,
    UserDataValue_UserDataInteger,
    UserDataValue_UserDataRect,
    UserDataValue_UserDataPoint,
    UserDataValue_UserDataString
  };
  return values;
}

inline const char * const *EnumNamesUserDataValue() {
  static const char * const names[] = {
    "NONE",
    "UserDataInteger",
    "UserDataRect",
    "UserDataPoint",
    "UserDataString",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserDataValue(UserDataValue e) {
  if (e < UserDataValue_NONE || e > UserDataValue_UserDataString) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserDataValue()[index];
}

template<typename T> struct UserDataValueTraits {
  static const UserDataValue enum_value = UserDataValue_NONE;
};

template<> struct UserDataValueTraits<UserDataInteger> {
  static const UserDataValue enum_value = UserDataValue_UserDataInteger;
};

template<> struct UserDataValueTraits<UserDataRect> {
  static const UserDataValue enum_value = UserDataValue_UserDataRect;
};

template<> struct UserDataValueTraits<UserDataPoint> {
  static const UserDataValue enum_value = UserDataValue_UserDataPoint;
};

template<> struct UserDataValueTraits<UserDataString> {
  static const UserDataValue enum_value = UserDataValue_UserDataString;
};

struct UserDataValueUnion {
  UserDataValue type;
  void *value;

  UserDataValueUnion() : type(UserDataValue_NONE), value(nullptr) {}
  UserDataValueUnion(UserDataValueUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(UserDataValue_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  UserDataValueUnion(const UserDataValueUnion &) FLATBUFFERS_NOEXCEPT;
  UserDataValueUnion &operator=(const UserDataValueUnion &u) FLATBUFFERS_NOEXCEPT
    { UserDataValueUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  UserDataValueUnion &operator=(UserDataValueUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~UserDataValueUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = UserDataValueTraits<typename RT::TableType>::enum_value;
    if (type != UserDataValue_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, UserDataValue type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  UserDataInteger *AsUserDataInteger() {
    return type == UserDataValue_UserDataInteger ?
      reinterpret_cast<UserDataInteger *>(value) : nullptr;
  }
  const UserDataInteger *AsUserDataInteger() const {
    return type == UserDataValue_UserDataInteger ?
      reinterpret_cast<const UserDataInteger *>(value) : nullptr;
  }
  UserDataRect *AsUserDataRect() {
    return type == UserDataValue_UserDataRect ?
      reinterpret_cast<UserDataRect *>(value) : nullptr;
  }
  const UserDataRect *AsUserDataRect() const {
    return type == UserDataValue_UserDataRect ?
      reinterpret_cast<const UserDataRect *>(value) : nullptr;
  }
  UserDataPoint *AsUserDataPoint() {
    return type == UserDataValue_UserDataPoint ?
      reinterpret_cast<UserDataPoint *>(value) : nullptr;
  }
  const UserDataPoint *AsUserDataPoint() const {
    return type == UserDataValue_UserDataPoint ?
      reinterpret_cast<const UserDataPoint *>(value) : nullptr;
  }
  UserDataStringT *AsUserDataString() {
    return type == UserDataValue_UserDataString ?
      reinterpret_cast<UserDataStringT *>(value) : nullptr;
  }
  const UserDataStringT *AsUserDataString() const {
    return type == UserDataValue_UserDataString ?
      reinterpret_cast<const UserDataStringT *>(value) : nullptr;
  }
};


inline bool operator==(const UserDataValueUnion &lhs, const UserDataValueUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case UserDataValue_NONE: {
      return true;
    }
    case UserDataValue_UserDataInteger: {
      return *(reinterpret_cast<const UserDataInteger *>(lhs.value)) ==
             *(reinterpret_cast<const UserDataInteger *>(rhs.value));
    }
    case UserDataValue_UserDataRect: {
      return *(reinterpret_cast<const UserDataRect *>(lhs.value)) ==
             *(reinterpret_cast<const UserDataRect *>(rhs.value));
    }
    case UserDataValue_UserDataPoint: {
      return *(reinterpret_cast<const UserDataPoint *>(lhs.value)) ==
             *(reinterpret_cast<const UserDataPoint *>(rhs.value));
    }
    case UserDataValue_UserDataString: {
      return *(reinterpret_cast<const UserDataStringT *>(lhs.value)) ==
             *(reinterpret_cast<const UserDataStringT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const UserDataValueUnion &lhs, const UserDataValueUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyUserDataValue(flatbuffers::Verifier &verifier, const void *obj, UserDataValue type);
bool VerifyUserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleInfiniteEmitEnabled FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t flag_;

 public:
  EffectParticleInfiniteEmitEnabled() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleInfiniteEmitEnabled));
  }
  EffectParticleInfiniteEmitEnabled(int32_t _flag)
      : flag_(flatbuffers::EndianScalar(_flag)) {
  }
  int32_t flag() const {
    return flatbuffers::EndianScalar(flag_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleInfiniteEmitEnabled, 4);

inline bool operator==(const EffectParticleInfiniteEmitEnabled &lhs, const EffectParticleInfiniteEmitEnabled &rhs) {
  return
      (lhs.flag() == rhs.flag());
}

inline bool operator!=(const EffectParticleInfiniteEmitEnabled &lhs, const EffectParticleInfiniteEmitEnabled &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleTurnToDirectionEnabled FLATBUFFERS_FINAL_CLASS {
 private:
  float rotation_;

 public:
  EffectParticleTurnToDirectionEnabled() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleTurnToDirectionEnabled));
  }
  EffectParticleTurnToDirectionEnabled(float _rotation)
      : rotation_(flatbuffers::EndianScalar(_rotation)) {
  }
  float rotation() const {
    return flatbuffers::EndianScalar(rotation_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleTurnToDirectionEnabled, 4);

inline bool operator==(const EffectParticleTurnToDirectionEnabled &lhs, const EffectParticleTurnToDirectionEnabled &rhs) {
  return
      (lhs.rotation() == rhs.rotation());
}

inline bool operator!=(const EffectParticleTurnToDirectionEnabled &lhs, const EffectParticleTurnToDirectionEnabled &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticlePointGravity FLATBUFFERS_FINAL_CLASS {
 private:
  float position_x_;
  float position_y_;
  float power_;

 public:
  EffectParticlePointGravity() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticlePointGravity));
  }
  EffectParticlePointGravity(float _position_x, float _position_y, float _power)
      : position_x_(flatbuffers::EndianScalar(_position_x)),
        position_y_(flatbuffers::EndianScalar(_position_y)),
        power_(flatbuffers::EndianScalar(_power)) {
  }
  float position_x() const {
    return flatbuffers::EndianScalar(position_x_);
  }
  float position_y() const {
    return flatbuffers::EndianScalar(position_y_);
  }
  float power() const {
    return flatbuffers::EndianScalar(power_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticlePointGravity, 12);

inline bool operator==(const EffectParticlePointGravity &lhs, const EffectParticlePointGravity &rhs) {
  return
      (lhs.position_x() == rhs.position_x()) &&
      (lhs.position_y() == rhs.position_y()) &&
      (lhs.power() == rhs.power());
}

inline bool operator!=(const EffectParticlePointGravity &lhs, const EffectParticlePointGravity &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransSize FLATBUFFERS_FINAL_CLASS {
 private:
  float size_x_min_value_;
  float size_x_max_value_;
  float size_y_min_value_;
  float size_y_max_value_;
  float scale_factor_min_value_;
  float scale_factor_max_value_;

 public:
  EffectParticleElementTransSize() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementTransSize));
  }
  EffectParticleElementTransSize(float _size_x_min_value, float _size_x_max_value, float _size_y_min_value, float _size_y_max_value, float _scale_factor_min_value, float _scale_factor_max_value)
      : size_x_min_value_(flatbuffers::EndianScalar(_size_x_min_value)),
        size_x_max_value_(flatbuffers::EndianScalar(_size_x_max_value)),
        size_y_min_value_(flatbuffers::EndianScalar(_size_y_min_value)),
        size_y_max_value_(flatbuffers::EndianScalar(_size_y_max_value)),
        scale_factor_min_value_(flatbuffers::EndianScalar(_scale_factor_min_value)),
        scale_factor_max_value_(flatbuffers::EndianScalar(_scale_factor_max_value)) {
  }
  float size_x_min_value() const {
    return flatbuffers::EndianScalar(size_x_min_value_);
  }
  float size_x_max_value() const {
    return flatbuffers::EndianScalar(size_x_max_value_);
  }
  float size_y_min_value() const {
    return flatbuffers::EndianScalar(size_y_min_value_);
  }
  float size_y_max_value() const {
    return flatbuffers::EndianScalar(size_y_max_value_);
  }
  float scale_factor_min_value() const {
    return flatbuffers::EndianScalar(scale_factor_min_value_);
  }
  float scale_factor_max_value() const {
    return flatbuffers::EndianScalar(scale_factor_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransSize, 24);

inline bool operator==(const EffectParticleElementTransSize &lhs, const EffectParticleElementTransSize &rhs) {
  return
      (lhs.size_x_min_value() == rhs.size_x_min_value()) &&
      (lhs.size_x_max_value() == rhs.size_x_max_value()) &&
      (lhs.size_y_min_value() == rhs.size_y_min_value()) &&
      (lhs.size_y_max_value() == rhs.size_y_max_value()) &&
      (lhs.scale_factor_min_value() == rhs.scale_factor_min_value()) &&
      (lhs.scale_factor_max_value() == rhs.scale_factor_max_value());
}

inline bool operator!=(const EffectParticleElementTransSize &lhs, const EffectParticleElementTransSize &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementSize FLATBUFFERS_FINAL_CLASS {
 private:
  float size_x_min_value_;
  float size_x_max_value_;
  float size_y_min_value_;
  float size_y_max_value_;
  float scale_factor_min_value_;
  float scale_factor_max_value_;

 public:
  EffectParticleElementSize() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementSize));
  }
  EffectParticleElementSize(float _size_x_min_value, float _size_x_max_value, float _size_y_min_value, float _size_y_max_value, float _scale_factor_min_value, float _scale_factor_max_value)
      : size_x_min_value_(flatbuffers::EndianScalar(_size_x_min_value)),
        size_x_max_value_(flatbuffers::EndianScalar(_size_x_max_value)),
        size_y_min_value_(flatbuffers::EndianScalar(_size_y_min_value)),
        size_y_max_value_(flatbuffers::EndianScalar(_size_y_max_value)),
        scale_factor_min_value_(flatbuffers::EndianScalar(_scale_factor_min_value)),
        scale_factor_max_value_(flatbuffers::EndianScalar(_scale_factor_max_value)) {
  }
  float size_x_min_value() const {
    return flatbuffers::EndianScalar(size_x_min_value_);
  }
  float size_x_max_value() const {
    return flatbuffers::EndianScalar(size_x_max_value_);
  }
  float size_y_min_value() const {
    return flatbuffers::EndianScalar(size_y_min_value_);
  }
  float size_y_max_value() const {
    return flatbuffers::EndianScalar(size_y_max_value_);
  }
  float scale_factor_min_value() const {
    return flatbuffers::EndianScalar(scale_factor_min_value_);
  }
  float scale_factor_max_value() const {
    return flatbuffers::EndianScalar(scale_factor_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementSize, 24);

inline bool operator==(const EffectParticleElementSize &lhs, const EffectParticleElementSize &rhs) {
  return
      (lhs.size_x_min_value() == rhs.size_x_min_value()) &&
      (lhs.size_x_max_value() == rhs.size_x_max_value()) &&
      (lhs.size_y_min_value() == rhs.size_y_min_value()) &&
      (lhs.size_y_max_value() == rhs.size_y_max_value()) &&
      (lhs.scale_factor_min_value() == rhs.scale_factor_min_value()) &&
      (lhs.scale_factor_max_value() == rhs.scale_factor_max_value());
}

inline bool operator!=(const EffectParticleElementSize &lhs, const EffectParticleElementSize &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementAlphaFade FLATBUFFERS_FINAL_CLASS {
 private:
  float disprange_min_value_;
  float disprange_max_value_;

 public:
  EffectParticleElementAlphaFade() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementAlphaFade));
  }
  EffectParticleElementAlphaFade(float _disprange_min_value, float _disprange_max_value)
      : disprange_min_value_(flatbuffers::EndianScalar(_disprange_min_value)),
        disprange_max_value_(flatbuffers::EndianScalar(_disprange_max_value)) {
  }
  float disprange_min_value() const {
    return flatbuffers::EndianScalar(disprange_min_value_);
  }
  float disprange_max_value() const {
    return flatbuffers::EndianScalar(disprange_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementAlphaFade, 8);

inline bool operator==(const EffectParticleElementAlphaFade &lhs, const EffectParticleElementAlphaFade &rhs) {
  return
      (lhs.disprange_min_value() == rhs.disprange_min_value()) &&
      (lhs.disprange_max_value() == rhs.disprange_max_value());
}

inline bool operator!=(const EffectParticleElementAlphaFade &lhs, const EffectParticleElementAlphaFade &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t color_min_value_;
  uint32_t color_max_value_;

 public:
  EffectParticleElementTransColor() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementTransColor));
  }
  EffectParticleElementTransColor(uint32_t _color_min_value, uint32_t _color_max_value)
      : color_min_value_(flatbuffers::EndianScalar(_color_min_value)),
        color_max_value_(flatbuffers::EndianScalar(_color_max_value)) {
  }
  uint32_t color_min_value() const {
    return flatbuffers::EndianScalar(color_min_value_);
  }
  uint32_t color_max_value() const {
    return flatbuffers::EndianScalar(color_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransColor, 8);

inline bool operator==(const EffectParticleElementTransColor &lhs, const EffectParticleElementTransColor &rhs) {
  return
      (lhs.color_min_value() == rhs.color_min_value()) &&
      (lhs.color_max_value() == rhs.color_max_value());
}

inline bool operator!=(const EffectParticleElementTransColor &lhs, const EffectParticleElementTransColor &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementInitColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t color_min_value_;
  uint32_t color_max_value_;

 public:
  EffectParticleElementInitColor() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementInitColor));
  }
  EffectParticleElementInitColor(uint32_t _color_min_value, uint32_t _color_max_value)
      : color_min_value_(flatbuffers::EndianScalar(_color_min_value)),
        color_max_value_(flatbuffers::EndianScalar(_color_max_value)) {
  }
  uint32_t color_min_value() const {
    return flatbuffers::EndianScalar(color_min_value_);
  }
  uint32_t color_max_value() const {
    return flatbuffers::EndianScalar(color_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementInitColor, 8);

inline bool operator==(const EffectParticleElementInitColor &lhs, const EffectParticleElementInitColor &rhs) {
  return
      (lhs.color_min_value() == rhs.color_min_value()) &&
      (lhs.color_max_value() == rhs.color_max_value());
}

inline bool operator!=(const EffectParticleElementInitColor &lhs, const EffectParticleElementInitColor &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTangentialAcceleration FLATBUFFERS_FINAL_CLASS {
 private:
  float acceleration_min_value_;
  float acceleration_max_value_;

 public:
  EffectParticleElementTangentialAcceleration() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementTangentialAcceleration));
  }
  EffectParticleElementTangentialAcceleration(float _acceleration_min_value, float _acceleration_max_value)
      : acceleration_min_value_(flatbuffers::EndianScalar(_acceleration_min_value)),
        acceleration_max_value_(flatbuffers::EndianScalar(_acceleration_max_value)) {
  }
  float acceleration_min_value() const {
    return flatbuffers::EndianScalar(acceleration_min_value_);
  }
  float acceleration_max_value() const {
    return flatbuffers::EndianScalar(acceleration_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTangentialAcceleration, 8);

inline bool operator==(const EffectParticleElementTangentialAcceleration &lhs, const EffectParticleElementTangentialAcceleration &rhs) {
  return
      (lhs.acceleration_min_value() == rhs.acceleration_min_value()) &&
      (lhs.acceleration_max_value() == rhs.acceleration_max_value());
}

inline bool operator!=(const EffectParticleElementTangentialAcceleration &lhs, const EffectParticleElementTangentialAcceleration &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransSpeed FLATBUFFERS_FINAL_CLASS {
 private:
  float speed_min_value_;
  float speed_max_value_;

 public:
  EffectParticleElementTransSpeed() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementTransSpeed));
  }
  EffectParticleElementTransSpeed(float _speed_min_value, float _speed_max_value)
      : speed_min_value_(flatbuffers::EndianScalar(_speed_min_value)),
        speed_max_value_(flatbuffers::EndianScalar(_speed_max_value)) {
  }
  float speed_min_value() const {
    return flatbuffers::EndianScalar(speed_min_value_);
  }
  float speed_max_value() const {
    return flatbuffers::EndianScalar(speed_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransSpeed, 8);

inline bool operator==(const EffectParticleElementTransSpeed &lhs, const EffectParticleElementTransSpeed &rhs) {
  return
      (lhs.speed_min_value() == rhs.speed_min_value()) &&
      (lhs.speed_max_value() == rhs.speed_max_value());
}

inline bool operator!=(const EffectParticleElementTransSpeed &lhs, const EffectParticleElementTransSpeed &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRotationTrans FLATBUFFERS_FINAL_CLASS {
 private:
  float rotation_factor_;
  float end_life_time_per_;

 public:
  EffectParticleElementRotationTrans() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementRotationTrans));
  }
  EffectParticleElementRotationTrans(float _rotation_factor, float _end_life_time_per)
      : rotation_factor_(flatbuffers::EndianScalar(_rotation_factor)),
        end_life_time_per_(flatbuffers::EndianScalar(_end_life_time_per)) {
  }
  float rotation_factor() const {
    return flatbuffers::EndianScalar(rotation_factor_);
  }
  float end_life_time_per() const {
    return flatbuffers::EndianScalar(end_life_time_per_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRotationTrans, 8);

inline bool operator==(const EffectParticleElementRotationTrans &lhs, const EffectParticleElementRotationTrans &rhs) {
  return
      (lhs.rotation_factor() == rhs.rotation_factor()) &&
      (lhs.end_life_time_per() == rhs.end_life_time_per());
}

inline bool operator!=(const EffectParticleElementRotationTrans &lhs, const EffectParticleElementRotationTrans &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRotation FLATBUFFERS_FINAL_CLASS {
 private:
  float rotation_min_value_;
  float rotation_max_value_;
  float rotation_add_min_value_;
  float rotation_add_max_value_;

 public:
  EffectParticleElementRotation() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementRotation));
  }
  EffectParticleElementRotation(float _rotation_min_value, float _rotation_max_value, float _rotation_add_min_value, float _rotation_add_max_value)
      : rotation_min_value_(flatbuffers::EndianScalar(_rotation_min_value)),
        rotation_max_value_(flatbuffers::EndianScalar(_rotation_max_value)),
        rotation_add_min_value_(flatbuffers::EndianScalar(_rotation_add_min_value)),
        rotation_add_max_value_(flatbuffers::EndianScalar(_rotation_add_max_value)) {
  }
  float rotation_min_value() const {
    return flatbuffers::EndianScalar(rotation_min_value_);
  }
  float rotation_max_value() const {
    return flatbuffers::EndianScalar(rotation_max_value_);
  }
  float rotation_add_min_value() const {
    return flatbuffers::EndianScalar(rotation_add_min_value_);
  }
  float rotation_add_max_value() const {
    return flatbuffers::EndianScalar(rotation_add_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRotation, 16);

inline bool operator==(const EffectParticleElementRotation &lhs, const EffectParticleElementRotation &rhs) {
  return
      (lhs.rotation_min_value() == rhs.rotation_min_value()) &&
      (lhs.rotation_max_value() == rhs.rotation_max_value()) &&
      (lhs.rotation_add_min_value() == rhs.rotation_add_min_value()) &&
      (lhs.rotation_add_max_value() == rhs.rotation_add_max_value());
}

inline bool operator!=(const EffectParticleElementRotation &lhs, const EffectParticleElementRotation &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementPosition FLATBUFFERS_FINAL_CLASS {
 private:
  float offset_x_min_value_;
  float offset_x_max_value_;
  float offset_y_min_value_;
  float offset_y_max_value_;

 public:
  EffectParticleElementPosition() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementPosition));
  }
  EffectParticleElementPosition(float _offset_x_min_value, float _offset_x_max_value, float _offset_y_min_value, float _offset_y_max_value)
      : offset_x_min_value_(flatbuffers::EndianScalar(_offset_x_min_value)),
        offset_x_max_value_(flatbuffers::EndianScalar(_offset_x_max_value)),
        offset_y_min_value_(flatbuffers::EndianScalar(_offset_y_min_value)),
        offset_y_max_value_(flatbuffers::EndianScalar(_offset_y_max_value)) {
  }
  float offset_x_min_value() const {
    return flatbuffers::EndianScalar(offset_x_min_value_);
  }
  float offset_x_max_value() const {
    return flatbuffers::EndianScalar(offset_x_max_value_);
  }
  float offset_y_min_value() const {
    return flatbuffers::EndianScalar(offset_y_min_value_);
  }
  float offset_y_max_value() const {
    return flatbuffers::EndianScalar(offset_y_max_value_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementPosition, 16);

inline bool operator==(const EffectParticleElementPosition &lhs, const EffectParticleElementPosition &rhs) {
  return
      (lhs.offset_x_min_value() == rhs.offset_x_min_value()) &&
      (lhs.offset_x_max_value() == rhs.offset_x_max_value()) &&
      (lhs.offset_y_min_value() == rhs.offset_y_min_value()) &&
      (lhs.offset_y_max_value() == rhs.offset_y_max_value());
}

inline bool operator!=(const EffectParticleElementPosition &lhs, const EffectParticleElementPosition &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementGravity FLATBUFFERS_FINAL_CLASS {
 private:
  float gravity_x_;
  float gravity_y_;

 public:
  EffectParticleElementGravity() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementGravity));
  }
  EffectParticleElementGravity(float _gravity_x, float _gravity_y)
      : gravity_x_(flatbuffers::EndianScalar(_gravity_x)),
        gravity_y_(flatbuffers::EndianScalar(_gravity_y)) {
  }
  float gravity_x() const {
    return flatbuffers::EndianScalar(gravity_x_);
  }
  float gravity_y() const {
    return flatbuffers::EndianScalar(gravity_y_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementGravity, 8);

inline bool operator==(const EffectParticleElementGravity &lhs, const EffectParticleElementGravity &rhs) {
  return
      (lhs.gravity_x() == rhs.gravity_x()) &&
      (lhs.gravity_y() == rhs.gravity_y());
}

inline bool operator!=(const EffectParticleElementGravity &lhs, const EffectParticleElementGravity &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementDelay FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t delay_time_;

 public:
  EffectParticleElementDelay() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementDelay));
  }
  EffectParticleElementDelay(int32_t _delay_time)
      : delay_time_(flatbuffers::EndianScalar(_delay_time)) {
  }
  int32_t delay_time() const {
    return flatbuffers::EndianScalar(delay_time_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementDelay, 4);

inline bool operator==(const EffectParticleElementDelay &lhs, const EffectParticleElementDelay &rhs) {
  return
      (lhs.delay_time() == rhs.delay_time());
}

inline bool operator!=(const EffectParticleElementDelay &lhs, const EffectParticleElementDelay &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRndSeedChange FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t seed_;

 public:
  EffectParticleElementRndSeedChange() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementRndSeedChange));
  }
  EffectParticleElementRndSeedChange(int32_t _seed)
      : seed_(flatbuffers::EndianScalar(_seed)) {
  }
  int32_t seed() const {
    return flatbuffers::EndianScalar(seed_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRndSeedChange, 4);

inline bool operator==(const EffectParticleElementRndSeedChange &lhs, const EffectParticleElementRndSeedChange &rhs) {
  return
      (lhs.seed() == rhs.seed());
}

inline bool operator!=(const EffectParticleElementRndSeedChange &lhs, const EffectParticleElementRndSeedChange &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementBasic FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t ss_effect_function_type_;
  int32_t priority_;
  int32_t maximum_particle_;
  int32_t attime_create_;
  int32_t interval_;
  int32_t lifetime_;
  float speed_min_value_;
  float speed_max_value_;
  int32_t lifespan_min_value_;
  int32_t lifespan_max_value_;
  float angle_;
  float angle_variance_;

 public:
  EffectParticleElementBasic() {
    memset(static_cast<void *>(this), 0, sizeof(EffectParticleElementBasic));
  }
  EffectParticleElementBasic(int32_t _ss_effect_function_type, int32_t _priority, int32_t _maximum_particle, int32_t _attime_create, int32_t _interval, int32_t _lifetime, float _speed_min_value, float _speed_max_value, int32_t _lifespan_min_value, int32_t _lifespan_max_value, float _angle, float _angle_variance)
      : ss_effect_function_type_(flatbuffers::EndianScalar(_ss_effect_function_type)),
        priority_(flatbuffers::EndianScalar(_priority)),
        maximum_particle_(flatbuffers::EndianScalar(_maximum_particle)),
        attime_create_(flatbuffers::EndianScalar(_attime_create)),
        interval_(flatbuffers::EndianScalar(_interval)),
        lifetime_(flatbuffers::EndianScalar(_lifetime)),
        speed_min_value_(flatbuffers::EndianScalar(_speed_min_value)),
        speed_max_value_(flatbuffers::EndianScalar(_speed_max_value)),
        lifespan_min_value_(flatbuffers::EndianScalar(_lifespan_min_value)),
        lifespan_max_value_(flatbuffers::EndianScalar(_lifespan_max_value)),
        angle_(flatbuffers::EndianScalar(_angle)),
        angle_variance_(flatbuffers::EndianScalar(_angle_variance)) {
  }
  int32_t ss_effect_function_type() const {
    return flatbuffers::EndianScalar(ss_effect_function_type_);
  }
  int32_t priority() const {
    return flatbuffers::EndianScalar(priority_);
  }
  int32_t maximum_particle() const {
    return flatbuffers::EndianScalar(maximum_particle_);
  }
  int32_t attime_create() const {
    return flatbuffers::EndianScalar(attime_create_);
  }
  int32_t interval() const {
    return flatbuffers::EndianScalar(interval_);
  }
  int32_t lifetime() const {
    return flatbuffers::EndianScalar(lifetime_);
  }
  float speed_min_value() const {
    return flatbuffers::EndianScalar(speed_min_value_);
  }
  float speed_max_value() const {
    return flatbuffers::EndianScalar(speed_max_value_);
  }
  int32_t lifespan_min_value() const {
    return flatbuffers::EndianScalar(lifespan_min_value_);
  }
  int32_t lifespan_max_value() const {
    return flatbuffers::EndianScalar(lifespan_max_value_);
  }
  float angle() const {
    return flatbuffers::EndianScalar(angle_);
  }
  float angle_variance() const {
    return flatbuffers::EndianScalar(angle_variance_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementBasic, 48);

inline bool operator==(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs) {
  return
      (lhs.ss_effect_function_type() == rhs.ss_effect_function_type()) &&
      (lhs.priority() == rhs.priority()) &&
      (lhs.maximum_particle() == rhs.maximum_particle()) &&
      (lhs.attime_create() == rhs.attime_create()) &&
      (lhs.interval() == rhs.interval()) &&
      (lhs.lifetime() == rhs.lifetime()) &&
      (lhs.speed_min_value() == rhs.speed_min_value()) &&
      (lhs.speed_max_value() == rhs.speed_max_value()) &&
      (lhs.lifespan_min_value() == rhs.lifespan_min_value()) &&
      (lhs.lifespan_max_value() == rhs.lifespan_max_value()) &&
      (lhs.angle() == rhs.angle()) &&
      (lhs.angle_variance() == rhs.angle_variance());
}

inline bool operator!=(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UserDataInteger FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t integer_;

 public:
  UserDataInteger() {
    memset(static_cast<void *>(this), 0, sizeof(UserDataInteger));
  }
  UserDataInteger(int32_t _integer)
      : integer_(flatbuffers::EndianScalar(_integer)) {
  }
  int32_t integer() const {
    return flatbuffers::EndianScalar(integer_);
  }
};
FLATBUFFERS_STRUCT_END(UserDataInteger, 4);

inline bool operator==(const UserDataInteger &lhs, const UserDataInteger &rhs) {
  return
      (lhs.integer() == rhs.integer());
}

inline bool operator!=(const UserDataInteger &lhs, const UserDataInteger &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UserDataRect FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t w_;
  int32_t h_;

 public:
  UserDataRect() {
    memset(static_cast<void *>(this), 0, sizeof(UserDataRect));
  }
  UserDataRect(int32_t _x, int32_t _y, int32_t _w, int32_t _h)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        w_(flatbuffers::EndianScalar(_w)),
        h_(flatbuffers::EndianScalar(_h)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
  int32_t h() const {
    return flatbuffers::EndianScalar(h_);
  }
};
FLATBUFFERS_STRUCT_END(UserDataRect, 16);

inline bool operator==(const UserDataRect &lhs, const UserDataRect &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y()) &&
      (lhs.w() == rhs.w()) &&
      (lhs.h() == rhs.h());
}

inline bool operator!=(const UserDataRect &lhs, const UserDataRect &rhs) {
    return !(lhs == rhs);
}


FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UserDataPoint FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  UserDataPoint() {
    memset(static_cast<void *>(this), 0, sizeof(UserDataPoint));
  }
  UserDataPoint(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(UserDataPoint, 8);

inline bool operator==(const UserDataPoint &lhs, const UserDataPoint &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y());
}

inline bool operator!=(const UserDataPoint &lhs, const UserDataPoint &rhs) {
    return !(lhs == rhs);
}


struct EffectNodeT : public flatbuffers::NativeTable {
  typedef EffectNode TableType;
  int16_t array_index;
  int16_t parent_index;
  EffectNodeType type;
  int16_t cell_index;
  EffectRenderBlendType blend_type;
  int16_t num_behavior;
  std::vector<EffectNodeBehaviorUnion> behavior;
  EffectNodeT()
      : array_index(0),
        parent_index(0),
        type(EffectNodeType_Root),
        cell_index(0),
        blend_type(EffectRenderBlendType_Mix),
        num_behavior(0) {
  }
};

inline bool operator==(const EffectNodeT &lhs, const EffectNodeT &rhs) {
  return
      (lhs.array_index == rhs.array_index) &&
      (lhs.parent_index == rhs.parent_index) &&
      (lhs.type == rhs.type) &&
      (lhs.cell_index == rhs.cell_index) &&
      (lhs.blend_type == rhs.blend_type) &&
      (lhs.num_behavior == rhs.num_behavior) &&
      (lhs.behavior == rhs.behavior);
}

inline bool operator!=(const EffectNodeT &lhs, const EffectNodeT &rhs) {
    return !(lhs == rhs);
}


struct EffectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EffectNodeT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARRAY_INDEX = 4,
    VT_PARENT_INDEX = 6,
    VT_TYPE = 8,
    VT_CELL_INDEX = 10,
    VT_BLEND_TYPE = 12,
    VT_NUM_BEHAVIOR = 14,
    VT_BEHAVIOR_TYPE = 16,
    VT_BEHAVIOR = 18
  };
  int16_t array_index() const {
    return GetField<int16_t>(VT_ARRAY_INDEX, 0);
  }
  int16_t parent_index() const {
    return GetField<int16_t>(VT_PARENT_INDEX, 0);
  }
  EffectNodeType type() const {
    return static_cast<EffectNodeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int16_t cell_index() const {
    return GetField<int16_t>(VT_CELL_INDEX, 0);
  }
  EffectRenderBlendType blend_type() const {
    return static_cast<EffectRenderBlendType>(GetField<int8_t>(VT_BLEND_TYPE, 0));
  }
  int16_t num_behavior() const {
    return GetField<int16_t>(VT_NUM_BEHAVIOR, 0);
  }
  const flatbuffers::Vector<uint8_t> *behavior_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BEHAVIOR_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *behavior() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_BEHAVIOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ARRAY_INDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENT_INDEX) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_CELL_INDEX) &&
           VerifyField<int8_t>(verifier, VT_BLEND_TYPE) &&
           VerifyField<int16_t>(verifier, VT_NUM_BEHAVIOR) &&
           VerifyOffset(verifier, VT_BEHAVIOR_TYPE) &&
           verifier.VerifyVector(behavior_type()) &&
           VerifyOffset(verifier, VT_BEHAVIOR) &&
           verifier.VerifyVector(behavior()) &&
           VerifyEffectNodeBehaviorVector(verifier, behavior(), behavior_type()) &&
           verifier.EndTable();
  }
  EffectNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EffectNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EffectNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EffectNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_array_index(int16_t array_index) {
    fbb_.AddElement<int16_t>(EffectNode::VT_ARRAY_INDEX, array_index, 0);
  }
  void add_parent_index(int16_t parent_index) {
    fbb_.AddElement<int16_t>(EffectNode::VT_PARENT_INDEX, parent_index, 0);
  }
  void add_type(EffectNodeType type) {
    fbb_.AddElement<int8_t>(EffectNode::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_cell_index(int16_t cell_index) {
    fbb_.AddElement<int16_t>(EffectNode::VT_CELL_INDEX, cell_index, 0);
  }
  void add_blend_type(EffectRenderBlendType blend_type) {
    fbb_.AddElement<int8_t>(EffectNode::VT_BLEND_TYPE, static_cast<int8_t>(blend_type), 0);
  }
  void add_num_behavior(int16_t num_behavior) {
    fbb_.AddElement<int16_t>(EffectNode::VT_NUM_BEHAVIOR, num_behavior, 0);
  }
  void add_behavior_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> behavior_type) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR_TYPE, behavior_type);
  }
  void add_behavior(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> behavior) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR, behavior);
  }
  explicit EffectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectNodeBuilder &operator=(const EffectNodeBuilder &);
  flatbuffers::Offset<EffectNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectNode> CreateEffectNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t array_index = 0,
    int16_t parent_index = 0,
    EffectNodeType type = EffectNodeType_Root,
    int16_t cell_index = 0,
    EffectRenderBlendType blend_type = EffectRenderBlendType_Mix,
    int16_t num_behavior = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> behavior_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> behavior = 0) {
  EffectNodeBuilder builder_(_fbb);
  builder_.add_behavior(behavior);
  builder_.add_behavior_type(behavior_type);
  builder_.add_num_behavior(num_behavior);
  builder_.add_cell_index(cell_index);
  builder_.add_parent_index(parent_index);
  builder_.add_array_index(array_index);
  builder_.add_blend_type(blend_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectNode> CreateEffectNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t array_index = 0,
    int16_t parent_index = 0,
    EffectNodeType type = EffectNodeType_Root,
    int16_t cell_index = 0,
    EffectRenderBlendType blend_type = EffectRenderBlendType_Mix,
    int16_t num_behavior = 0,
    const std::vector<uint8_t> *behavior_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *behavior = nullptr) {
  auto behavior_type__ = behavior_type ? _fbb.CreateVector<uint8_t>(*behavior_type) : 0;
  auto behavior__ = behavior ? _fbb.CreateVector<flatbuffers::Offset<void>>(*behavior) : 0;
  return ss::ssfb::CreateEffectNode(
      _fbb,
      array_index,
      parent_index,
      type,
      cell_index,
      blend_type,
      num_behavior,
      behavior_type__,
      behavior__);
}

flatbuffers::Offset<EffectNode> CreateEffectNode(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EffectFileT : public flatbuffers::NativeTable {
  typedef EffectFile TableType;
  std::string name;
  int16_t fps;
  int16_t is_lock_rand_seed;
  int16_t lock_rand_seed;
  int16_t layout_scale_x;
  int16_t layout_scale_y;
  int16_t num_node_list;
  std::vector<std::unique_ptr<EffectNodeT>> effect_node;
  EffectFileT()
      : fps(0),
        is_lock_rand_seed(0),
        lock_rand_seed(0),
        layout_scale_x(0),
        layout_scale_y(0),
        num_node_list(0) {
  }
};

inline bool operator==(const EffectFileT &lhs, const EffectFileT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.fps == rhs.fps) &&
      (lhs.is_lock_rand_seed == rhs.is_lock_rand_seed) &&
      (lhs.lock_rand_seed == rhs.lock_rand_seed) &&
      (lhs.layout_scale_x == rhs.layout_scale_x) &&
      (lhs.layout_scale_y == rhs.layout_scale_y) &&
      (lhs.num_node_list == rhs.num_node_list) &&
      (lhs.effect_node == rhs.effect_node);
}

inline bool operator!=(const EffectFileT &lhs, const EffectFileT &rhs) {
    return !(lhs == rhs);
}


struct EffectFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EffectFileT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FPS = 6,
    VT_IS_LOCK_RAND_SEED = 8,
    VT_LOCK_RAND_SEED = 10,
    VT_LAYOUT_SCALE_X = 12,
    VT_LAYOUT_SCALE_Y = 14,
    VT_NUM_NODE_LIST = 16,
    VT_EFFECT_NODE = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t is_lock_rand_seed() const {
    return GetField<int16_t>(VT_IS_LOCK_RAND_SEED, 0);
  }
  int16_t lock_rand_seed() const {
    return GetField<int16_t>(VT_LOCK_RAND_SEED, 0);
  }
  int16_t layout_scale_x() const {
    return GetField<int16_t>(VT_LAYOUT_SCALE_X, 0);
  }
  int16_t layout_scale_y() const {
    return GetField<int16_t>(VT_LAYOUT_SCALE_Y, 0);
  }
  int16_t num_node_list() const {
    return GetField<int16_t>(VT_NUM_NODE_LIST, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *effect_node() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *>(VT_EFFECT_NODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_IS_LOCK_RAND_SEED) &&
           VerifyField<int16_t>(verifier, VT_LOCK_RAND_SEED) &&
           VerifyField<int16_t>(verifier, VT_LAYOUT_SCALE_X) &&
           VerifyField<int16_t>(verifier, VT_LAYOUT_SCALE_Y) &&
           VerifyField<int16_t>(verifier, VT_NUM_NODE_LIST) &&
           VerifyOffset(verifier, VT_EFFECT_NODE) &&
           verifier.VerifyVector(effect_node()) &&
           verifier.VerifyVectorOfTables(effect_node()) &&
           verifier.EndTable();
  }
  EffectFileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EffectFileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EffectFile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EffectFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EffectFile::VT_NAME, name);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(EffectFile::VT_FPS, fps, 0);
  }
  void add_is_lock_rand_seed(int16_t is_lock_rand_seed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_IS_LOCK_RAND_SEED, is_lock_rand_seed, 0);
  }
  void add_lock_rand_seed(int16_t lock_rand_seed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LOCK_RAND_SEED, lock_rand_seed, 0);
  }
  void add_layout_scale_x(int16_t layout_scale_x) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUT_SCALE_X, layout_scale_x, 0);
  }
  void add_layout_scale_y(int16_t layout_scale_y) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUT_SCALE_Y, layout_scale_y, 0);
  }
  void add_num_node_list(int16_t num_node_list) {
    fbb_.AddElement<int16_t>(EffectFile::VT_NUM_NODE_LIST, num_node_list, 0);
  }
  void add_effect_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effect_node) {
    fbb_.AddOffset(EffectFile::VT_EFFECT_NODE, effect_node);
  }
  explicit EffectFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectFileBuilder &operator=(const EffectFileBuilder &);
  flatbuffers::Offset<EffectFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectFile> CreateEffectFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t fps = 0,
    int16_t is_lock_rand_seed = 0,
    int16_t lock_rand_seed = 0,
    int16_t layout_scale_x = 0,
    int16_t layout_scale_y = 0,
    int16_t num_node_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effect_node = 0) {
  EffectFileBuilder builder_(_fbb);
  builder_.add_effect_node(effect_node);
  builder_.add_name(name);
  builder_.add_num_node_list(num_node_list);
  builder_.add_layout_scale_y(layout_scale_y);
  builder_.add_layout_scale_x(layout_scale_x);
  builder_.add_lock_rand_seed(lock_rand_seed);
  builder_.add_is_lock_rand_seed(is_lock_rand_seed);
  builder_.add_fps(fps);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectFile> CreateEffectFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t fps = 0,
    int16_t is_lock_rand_seed = 0,
    int16_t lock_rand_seed = 0,
    int16_t layout_scale_x = 0,
    int16_t layout_scale_y = 0,
    int16_t num_node_list = 0,
    const std::vector<flatbuffers::Offset<EffectNode>> *effect_node = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto effect_node__ = effect_node ? _fbb.CreateVector<flatbuffers::Offset<EffectNode>>(*effect_node) : 0;
  return ss::ssfb::CreateEffectFile(
      _fbb,
      name__,
      fps,
      is_lock_rand_seed,
      lock_rand_seed,
      layout_scale_x,
      layout_scale_y,
      num_node_list,
      effect_node__);
}

flatbuffers::Offset<EffectFile> CreateEffectFile(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellMapT : public flatbuffers::NativeTable {
  typedef CellMap TableType;
  std::string name;
  std::string image_path;
  int16_t index;
  int16_t wrap_mode;
  int16_t filter_mode;
  CellMapT()
      : index(0),
        wrap_mode(0),
        filter_mode(0) {
  }
};

inline bool operator==(const CellMapT &lhs, const CellMapT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.image_path == rhs.image_path) &&
      (lhs.index == rhs.index) &&
      (lhs.wrap_mode == rhs.wrap_mode) &&
      (lhs.filter_mode == rhs.filter_mode);
}

inline bool operator!=(const CellMapT &lhs, const CellMapT &rhs) {
    return !(lhs == rhs);
}


struct CellMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellMapT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_IMAGE_PATH = 6,
    VT_INDEX = 8,
    VT_WRAP_MODE = 10,
    VT_FILTER_MODE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *image_path() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGE_PATH);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t wrap_mode() const {
    return GetField<int16_t>(VT_WRAP_MODE, 0);
  }
  int16_t filter_mode() const {
    return GetField<int16_t>(VT_FILTER_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_IMAGE_PATH) &&
           verifier.VerifyString(image_path()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_WRAP_MODE) &&
           VerifyField<int16_t>(verifier, VT_FILTER_MODE) &&
           verifier.EndTable();
  }
  CellMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CellMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CellMap::VT_NAME, name);
  }
  void add_image_path(flatbuffers::Offset<flatbuffers::String> image_path) {
    fbb_.AddOffset(CellMap::VT_IMAGE_PATH, image_path);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(CellMap::VT_INDEX, index, 0);
  }
  void add_wrap_mode(int16_t wrap_mode) {
    fbb_.AddElement<int16_t>(CellMap::VT_WRAP_MODE, wrap_mode, 0);
  }
  void add_filter_mode(int16_t filter_mode) {
    fbb_.AddElement<int16_t>(CellMap::VT_FILTER_MODE, filter_mode, 0);
  }
  explicit CellMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellMapBuilder &operator=(const CellMapBuilder &);
  flatbuffers::Offset<CellMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellMap> CreateCellMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> image_path = 0,
    int16_t index = 0,
    int16_t wrap_mode = 0,
    int16_t filter_mode = 0) {
  CellMapBuilder builder_(_fbb);
  builder_.add_image_path(image_path);
  builder_.add_name(name);
  builder_.add_filter_mode(filter_mode);
  builder_.add_wrap_mode(wrap_mode);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<CellMap> CreateCellMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *image_path = nullptr,
    int16_t index = 0,
    int16_t wrap_mode = 0,
    int16_t filter_mode = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto image_path__ = image_path ? _fbb.CreateString(image_path) : 0;
  return ss::ssfb::CreateCellMap(
      _fbb,
      name__,
      image_path__,
      index,
      wrap_mode,
      filter_mode);
}

flatbuffers::Offset<CellMap> CreateCellMap(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellT : public flatbuffers::NativeTable {
  typedef Cell TableType;
  std::string name;
  std::unique_ptr<CellMapT> cell_map;
  int16_t index_in_cell_map;
  int16_t x;
  int16_t y;
  int16_t width;
  int16_t height;
  float pivot_x;
  float pivot_y;
  float u1;
  float v1;
  float u2;
  float v2;
  CellT()
      : index_in_cell_map(0),
        x(0),
        y(0),
        width(0),
        height(0),
        pivot_x(0.0f),
        pivot_y(0.0f),
        u1(0.0f),
        v1(0.0f),
        u2(0.0f),
        v2(0.0f) {
  }
};

inline bool operator==(const CellT &lhs, const CellT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.cell_map == rhs.cell_map) &&
      (lhs.index_in_cell_map == rhs.index_in_cell_map) &&
      (lhs.x == rhs.x) &&
      (lhs.y == rhs.y) &&
      (lhs.width == rhs.width) &&
      (lhs.height == rhs.height) &&
      (lhs.pivot_x == rhs.pivot_x) &&
      (lhs.pivot_y == rhs.pivot_y) &&
      (lhs.u1 == rhs.u1) &&
      (lhs.v1 == rhs.v1) &&
      (lhs.u2 == rhs.u2) &&
      (lhs.v2 == rhs.v2);
}

inline bool operator!=(const CellT &lhs, const CellT &rhs) {
    return !(lhs == rhs);
}


struct Cell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CELL_MAP = 6,
    VT_INDEX_IN_CELL_MAP = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_WIDTH = 14,
    VT_HEIGHT = 16,
    VT_PIVOT_X = 18,
    VT_PIVOT_Y = 20,
    VT_U1 = 22,
    VT_V1 = 24,
    VT_U2 = 26,
    VT_V2 = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const CellMap *cell_map() const {
    return GetPointer<const CellMap *>(VT_CELL_MAP);
  }
  int16_t index_in_cell_map() const {
    return GetField<int16_t>(VT_INDEX_IN_CELL_MAP, 0);
  }
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  int16_t width() const {
    return GetField<int16_t>(VT_WIDTH, 0);
  }
  int16_t height() const {
    return GetField<int16_t>(VT_HEIGHT, 0);
  }
  float pivot_x() const {
    return GetField<float>(VT_PIVOT_X, 0.0f);
  }
  float pivot_y() const {
    return GetField<float>(VT_PIVOT_Y, 0.0f);
  }
  float u1() const {
    return GetField<float>(VT_U1, 0.0f);
  }
  float v1() const {
    return GetField<float>(VT_V1, 0.0f);
  }
  float u2() const {
    return GetField<float>(VT_U2, 0.0f);
  }
  float v2() const {
    return GetField<float>(VT_V2, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CELL_MAP) &&
           verifier.VerifyTable(cell_map()) &&
           VerifyField<int16_t>(verifier, VT_INDEX_IN_CELL_MAP) &&
           VerifyField<int16_t>(verifier, VT_X) &&
           VerifyField<int16_t>(verifier, VT_Y) &&
           VerifyField<int16_t>(verifier, VT_WIDTH) &&
           VerifyField<int16_t>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_PIVOT_X) &&
           VerifyField<float>(verifier, VT_PIVOT_Y) &&
           VerifyField<float>(verifier, VT_U1) &&
           VerifyField<float>(verifier, VT_V1) &&
           VerifyField<float>(verifier, VT_U2) &&
           VerifyField<float>(verifier, VT_V2) &&
           verifier.EndTable();
  }
  CellT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cell> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Cell::VT_NAME, name);
  }
  void add_cell_map(flatbuffers::Offset<CellMap> cell_map) {
    fbb_.AddOffset(Cell::VT_CELL_MAP, cell_map);
  }
  void add_index_in_cell_map(int16_t index_in_cell_map) {
    fbb_.AddElement<int16_t>(Cell::VT_INDEX_IN_CELL_MAP, index_in_cell_map, 0);
  }
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(Cell::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(Cell::VT_Y, y, 0);
  }
  void add_width(int16_t width) {
    fbb_.AddElement<int16_t>(Cell::VT_WIDTH, width, 0);
  }
  void add_height(int16_t height) {
    fbb_.AddElement<int16_t>(Cell::VT_HEIGHT, height, 0);
  }
  void add_pivot_x(float pivot_x) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_X, pivot_x, 0.0f);
  }
  void add_pivot_y(float pivot_y) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_Y, pivot_y, 0.0f);
  }
  void add_u1(float u1) {
    fbb_.AddElement<float>(Cell::VT_U1, u1, 0.0f);
  }
  void add_v1(float v1) {
    fbb_.AddElement<float>(Cell::VT_V1, v1, 0.0f);
  }
  void add_u2(float u2) {
    fbb_.AddElement<float>(Cell::VT_U2, u2, 0.0f);
  }
  void add_v2(float v2) {
    fbb_.AddElement<float>(Cell::VT_V2, v2, 0.0f);
  }
  explicit CellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellBuilder &operator=(const CellBuilder &);
  flatbuffers::Offset<Cell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cell>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cell> CreateCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<CellMap> cell_map = 0,
    int16_t index_in_cell_map = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  CellBuilder builder_(_fbb);
  builder_.add_v2(v2);
  builder_.add_u2(u2);
  builder_.add_v1(v1);
  builder_.add_u1(u1);
  builder_.add_pivot_y(pivot_y);
  builder_.add_pivot_x(pivot_x);
  builder_.add_cell_map(cell_map);
  builder_.add_name(name);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_index_in_cell_map(index_in_cell_map);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cell> CreateCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<CellMap> cell_map = 0,
    int16_t index_in_cell_map = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ss::ssfb::CreateCell(
      _fbb,
      name__,
      cell_map,
      index_in_cell_map,
      x,
      y,
      width,
      height,
      pivot_x,
      pivot_y,
      u1,
      v1,
      u2,
      v2);
}

flatbuffers::Offset<Cell> CreateCell(flatbuffers::FlatBufferBuilder &_fbb, const CellT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshDataUVT : public flatbuffers::NativeTable {
  typedef MeshDataUV TableType;
  std::vector<float> uv;
  MeshDataUVT() {
  }
};

inline bool operator==(const MeshDataUVT &lhs, const MeshDataUVT &rhs) {
  return
      (lhs.uv == rhs.uv);
}

inline bool operator!=(const MeshDataUVT &lhs, const MeshDataUVT &rhs) {
    return !(lhs == rhs);
}


struct MeshDataUV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshDataUVT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UV = 4
  };
  const flatbuffers::Vector<float> *uv() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_UV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UV) &&
           verifier.VerifyVector(uv()) &&
           verifier.EndTable();
  }
  MeshDataUVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshDataUVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeshDataUV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshDataUVBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uv(flatbuffers::Offset<flatbuffers::Vector<float>> uv) {
    fbb_.AddOffset(MeshDataUV::VT_UV, uv);
  }
  explicit MeshDataUVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshDataUVBuilder &operator=(const MeshDataUVBuilder &);
  flatbuffers::Offset<MeshDataUV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshDataUV>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshDataUV> CreateMeshDataUV(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> uv = 0) {
  MeshDataUVBuilder builder_(_fbb);
  builder_.add_uv(uv);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshDataUV> CreateMeshDataUVDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *uv = nullptr) {
  auto uv__ = uv ? _fbb.CreateVector<float>(*uv) : 0;
  return ss::ssfb::CreateMeshDataUV(
      _fbb,
      uv__);
}

flatbuffers::Offset<MeshDataUV> CreateMeshDataUV(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshDataIndicesT : public flatbuffers::NativeTable {
  typedef MeshDataIndices TableType;
  std::vector<float> indices;
  MeshDataIndicesT() {
  }
};

inline bool operator==(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs) {
  return
      (lhs.indices == rhs.indices);
}

inline bool operator!=(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs) {
    return !(lhs == rhs);
}


struct MeshDataIndices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshDataIndicesT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICES = 4
  };
  const flatbuffers::Vector<float> *indices() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
  MeshDataIndicesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshDataIndicesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeshDataIndices> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshDataIndicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<float>> indices) {
    fbb_.AddOffset(MeshDataIndices::VT_INDICES, indices);
  }
  explicit MeshDataIndicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshDataIndicesBuilder &operator=(const MeshDataIndicesBuilder &);
  flatbuffers::Offset<MeshDataIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshDataIndices>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> indices = 0) {
  MeshDataIndicesBuilder builder_(_fbb);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *indices = nullptr) {
  auto indices__ = indices ? _fbb.CreateVector<float>(*indices) : 0;
  return ss::ssfb::CreateMeshDataIndices(
      _fbb,
      indices__);
}

flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndices(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartStateT : public flatbuffers::NativeTable {
  typedef PartState TableType;
  int16_t index;
  uint32_t flag1;
  uint32_t flag2;
  std::vector<uint32_t> data;
  PartStateT()
      : index(0),
        flag1(0),
        flag2(0) {
  }
};

inline bool operator==(const PartStateT &lhs, const PartStateT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.flag1 == rhs.flag1) &&
      (lhs.flag2 == rhs.flag2) &&
      (lhs.data == rhs.data);
}

inline bool operator!=(const PartStateT &lhs, const PartStateT &rhs) {
    return !(lhs == rhs);
}


struct PartState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartStateT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_FLAG1 = 6,
    VT_FLAG2 = 8,
    VT_DATA = 10
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  uint32_t flag1() const {
    return GetField<uint32_t>(VT_FLAG1, 0);
  }
  uint32_t flag2() const {
    return GetField<uint32_t>(VT_FLAG2, 0);
  }
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_FLAG1) &&
           VerifyField<uint32_t>(verifier, VT_FLAG2) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  PartStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(PartState::VT_INDEX, index, 0);
  }
  void add_flag1(uint32_t flag1) {
    fbb_.AddElement<uint32_t>(PartState::VT_FLAG1, flag1, 0);
  }
  void add_flag2(uint32_t flag2) {
    fbb_.AddElement<uint32_t>(PartState::VT_FLAG2, flag2, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(PartState::VT_DATA, data);
  }
  explicit PartStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartStateBuilder &operator=(const PartStateBuilder &);
  flatbuffers::Offset<PartState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartState>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartState> CreatePartState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    uint32_t flag1 = 0,
    uint32_t flag2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  PartStateBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_flag2(flag2);
  builder_.add_flag1(flag1);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartState> CreatePartStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    uint32_t flag1 = 0,
    uint32_t flag2 = 0,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return ss::ssfb::CreatePartState(
      _fbb,
      index,
      flag1,
      flag2,
      data__);
}

flatbuffers::Offset<PartState> CreatePartState(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameDataIndexT : public flatbuffers::NativeTable {
  typedef FrameDataIndex TableType;
  std::vector<std::unique_ptr<PartStateT>> states;
  FrameDataIndexT() {
  }
};

inline bool operator==(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs) {
  return
      (lhs.states == rhs.states);
}

inline bool operator!=(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs) {
    return !(lhs == rhs);
}


struct FrameDataIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameDataIndexT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PartState>> *states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PartState>> *>(VT_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.VerifyVector(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           verifier.EndTable();
  }
  FrameDataIndexT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameDataIndexT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FrameDataIndex> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameDataIndexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartState>>> states) {
    fbb_.AddOffset(FrameDataIndex::VT_STATES, states);
  }
  explicit FrameDataIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameDataIndexBuilder &operator=(const FrameDataIndexBuilder &);
  flatbuffers::Offset<FrameDataIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameDataIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartState>>> states = 0) {
  FrameDataIndexBuilder builder_(_fbb);
  builder_.add_states(states);
  return builder_.Finish();
}

inline flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PartState>> *states = nullptr) {
  auto states__ = states ? _fbb.CreateVector<flatbuffers::Offset<PartState>>(*states) : 0;
  return ss::ssfb::CreateFrameDataIndex(
      _fbb,
      states__);
}

flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndex(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UserDataStringT : public flatbuffers::NativeTable {
  typedef UserDataString TableType;
  int32_t length;
  std::string data;
  UserDataStringT()
      : length(0) {
  }
};

inline bool operator==(const UserDataStringT &lhs, const UserDataStringT &rhs) {
  return
      (lhs.length == rhs.length) &&
      (lhs.data == rhs.data);
}

inline bool operator!=(const UserDataStringT &lhs, const UserDataStringT &rhs) {
    return !(lhs == rhs);
}


struct UserDataString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserDataStringT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LENGTH = 4,
    VT_DATA = 6
  };
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
  UserDataStringT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UserDataStringT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UserDataString> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataStringT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UserDataStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(UserDataString::VT_LENGTH, length, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(UserDataString::VT_DATA, data);
  }
  explicit UserDataStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserDataStringBuilder &operator=(const UserDataStringBuilder &);
  flatbuffers::Offset<UserDataString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserDataString>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserDataString> CreateUserDataString(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  UserDataStringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_length(length);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserDataString> CreateUserDataStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return ss::ssfb::CreateUserDataString(
      _fbb,
      length,
      data__);
}

flatbuffers::Offset<UserDataString> CreateUserDataString(flatbuffers::FlatBufferBuilder &_fbb, const UserDataStringT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UserDataItemT : public flatbuffers::NativeTable {
  typedef UserDataItem TableType;
  UserDataFlag flags;
  int16_t array_index;
  std::vector<UserDataValueUnion> data;
  UserDataItemT()
      : flags(static_cast<UserDataFlag>(0)),
        array_index(0) {
  }
};

inline bool operator==(const UserDataItemT &lhs, const UserDataItemT &rhs) {
  return
      (lhs.flags == rhs.flags) &&
      (lhs.array_index == rhs.array_index) &&
      (lhs.data == rhs.data);
}

inline bool operator!=(const UserDataItemT &lhs, const UserDataItemT &rhs) {
    return !(lhs == rhs);
}


struct UserDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserDataItemT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_ARRAY_INDEX = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  UserDataFlag flags() const {
    return static_cast<UserDataFlag>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  int16_t array_index() const {
    return GetField<int16_t>(VT_ARRAY_INDEX, 0);
  }
  const flatbuffers::Vector<uint8_t> *data_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS) &&
           VerifyField<int16_t>(verifier, VT_ARRAY_INDEX) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.VerifyVector(data_type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyUserDataValueVector(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  UserDataItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UserDataItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UserDataItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UserDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(UserDataFlag flags) {
    fbb_.AddElement<uint8_t>(UserDataItem::VT_FLAGS, static_cast<uint8_t>(flags), 0);
  }
  void add_array_index(int16_t array_index) {
    fbb_.AddElement<int16_t>(UserDataItem::VT_ARRAY_INDEX, array_index, 0);
  }
  void add_data_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type) {
    fbb_.AddOffset(UserDataItem::VT_DATA_TYPE, data_type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data) {
    fbb_.AddOffset(UserDataItem::VT_DATA, data);
  }
  explicit UserDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserDataItemBuilder &operator=(const UserDataItemBuilder &);
  flatbuffers::Offset<UserDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserDataItem> CreateUserDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    UserDataFlag flags = static_cast<UserDataFlag>(0),
    int16_t array_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data = 0) {
  UserDataItemBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_array_index(array_index);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserDataItem> CreateUserDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    UserDataFlag flags = static_cast<UserDataFlag>(0),
    int16_t array_index = 0,
    const std::vector<uint8_t> *data_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *data = nullptr) {
  auto data_type__ = data_type ? _fbb.CreateVector<uint8_t>(*data_type) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<void>>(*data) : 0;
  return ss::ssfb::CreateUserDataItem(
      _fbb,
      flags,
      array_index,
      data_type__,
      data__);
}

flatbuffers::Offset<UserDataItem> CreateUserDataItem(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UserDataPerFrameT : public flatbuffers::NativeTable {
  typedef UserDataPerFrame TableType;
  int16_t frame_index;
  std::vector<std::unique_ptr<UserDataItemT>> data;
  UserDataPerFrameT()
      : frame_index(0) {
  }
};

inline bool operator==(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs) {
  return
      (lhs.frame_index == rhs.frame_index) &&
      (lhs.data == rhs.data);
}

inline bool operator!=(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs) {
    return !(lhs == rhs);
}


struct UserDataPerFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserDataPerFrameT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_INDEX = 4,
    VT_DATA = 6
  };
  int16_t frame_index() const {
    return GetField<int16_t>(VT_FRAME_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UserDataItem>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserDataItem>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FRAME_INDEX) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  UserDataPerFrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UserDataPerFrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UserDataPerFrame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UserDataPerFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame_index(int16_t frame_index) {
    fbb_.AddElement<int16_t>(UserDataPerFrame::VT_FRAME_INDEX, frame_index, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserDataItem>>> data) {
    fbb_.AddOffset(UserDataPerFrame::VT_DATA, data);
  }
  explicit UserDataPerFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserDataPerFrameBuilder &operator=(const UserDataPerFrameBuilder &);
  flatbuffers::Offset<UserDataPerFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserDataPerFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frame_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserDataItem>>> data = 0) {
  UserDataPerFrameBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_frame_index(frame_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frame_index = 0,
    const std::vector<flatbuffers::Offset<UserDataItem>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<UserDataItem>>(*data) : 0;
  return ss::ssfb::CreateUserDataPerFrame(
      _fbb,
      frame_index,
      data__);
}

flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrame(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LabelDataItemT : public flatbuffers::NativeTable {
  typedef LabelDataItem TableType;
  std::string label;
  int16_t frame_index;
  LabelDataItemT()
      : frame_index(0) {
  }
};

inline bool operator==(const LabelDataItemT &lhs, const LabelDataItemT &rhs) {
  return
      (lhs.label == rhs.label) &&
      (lhs.frame_index == rhs.frame_index);
}

inline bool operator!=(const LabelDataItemT &lhs, const LabelDataItemT &rhs) {
    return !(lhs == rhs);
}


struct LabelDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LabelDataItemT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_FRAME_INDEX = 6
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  int16_t frame_index() const {
    return GetField<int16_t>(VT_FRAME_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<int16_t>(verifier, VT_FRAME_INDEX) &&
           verifier.EndTable();
  }
  LabelDataItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LabelDataItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LabelDataItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LabelDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(LabelDataItem::VT_LABEL, label);
  }
  void add_frame_index(int16_t frame_index) {
    fbb_.AddElement<int16_t>(LabelDataItem::VT_FRAME_INDEX, frame_index, 0);
  }
  explicit LabelDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LabelDataItemBuilder &operator=(const LabelDataItemBuilder &);
  flatbuffers::Offset<LabelDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LabelDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<LabelDataItem> CreateLabelDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    int16_t frame_index = 0) {
  LabelDataItemBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_frame_index(frame_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<LabelDataItem> CreateLabelDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    int16_t frame_index = 0) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  return ss::ssfb::CreateLabelDataItem(
      _fbb,
      label__,
      frame_index);
}

flatbuffers::Offset<LabelDataItem> CreateLabelDataItem(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimationDataT : public flatbuffers::NativeTable {
  typedef AnimationData TableType;
  std::string name;
  std::vector<std::unique_ptr<AnimationInitialDataT>> default_data;
  std::vector<std::unique_ptr<FrameDataIndexT>> frame_data;
  std::vector<std::unique_ptr<UserDataPerFrameT>> user_data;
  std::vector<std::unique_ptr<LabelDataItemT>> label_data;
  std::vector<std::unique_ptr<MeshDataUVT>> meshs_data_UV;
  std::vector<std::unique_ptr<MeshDataIndicesT>> meshs_data_indices;
  int16_t start_frames;
  int16_t end_frames;
  int16_t total_frames;
  int16_t fps;
  int16_t labelNum;
  int16_t canvas_size_w;
  int16_t canvas_size_h;
  float canvas_pvot_x;
  float canvas_pvot_y;
  AnimationDataT()
      : start_frames(0),
        end_frames(0),
        total_frames(0),
        fps(0),
        labelNum(0),
        canvas_size_w(0),
        canvas_size_h(0),
        canvas_pvot_x(0.0f),
        canvas_pvot_y(0.0f) {
  }
};

inline bool operator==(const AnimationDataT &lhs, const AnimationDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.default_data == rhs.default_data) &&
      (lhs.frame_data == rhs.frame_data) &&
      (lhs.user_data == rhs.user_data) &&
      (lhs.label_data == rhs.label_data) &&
      (lhs.meshs_data_UV == rhs.meshs_data_UV) &&
      (lhs.meshs_data_indices == rhs.meshs_data_indices) &&
      (lhs.start_frames == rhs.start_frames) &&
      (lhs.end_frames == rhs.end_frames) &&
      (lhs.total_frames == rhs.total_frames) &&
      (lhs.fps == rhs.fps) &&
      (lhs.labelNum == rhs.labelNum) &&
      (lhs.canvas_size_w == rhs.canvas_size_w) &&
      (lhs.canvas_size_h == rhs.canvas_size_h) &&
      (lhs.canvas_pvot_x == rhs.canvas_pvot_x) &&
      (lhs.canvas_pvot_y == rhs.canvas_pvot_y);
}

inline bool operator!=(const AnimationDataT &lhs, const AnimationDataT &rhs) {
    return !(lhs == rhs);
}


struct AnimationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationDataT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DEFAULT_DATA = 6,
    VT_FRAME_DATA = 8,
    VT_USER_DATA = 10,
    VT_LABEL_DATA = 12,
    VT_MESHS_DATA_UV = 14,
    VT_MESHS_DATA_INDICES = 16,
    VT_START_FRAMES = 18,
    VT_END_FRAMES = 20,
    VT_TOTAL_FRAMES = 22,
    VT_FPS = 24,
    VT_LABELNUM = 26,
    VT_CANVAS_SIZE_W = 28,
    VT_CANVAS_SIZE_H = 30,
    VT_CANVAS_PVOT_X = 32,
    VT_CANVAS_PVOT_Y = 34
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *default_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *>(VT_DEFAULT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FrameDataIndex>> *frame_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FrameDataIndex>> *>(VT_FRAME_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UserDataPerFrame>> *user_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserDataPerFrame>> *>(VT_USER_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LabelDataItem>> *label_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LabelDataItem>> *>(VT_LABEL_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MeshDataUV>> *meshs_data_UV() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshDataUV>> *>(VT_MESHS_DATA_UV);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MeshDataIndices>> *meshs_data_indices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshDataIndices>> *>(VT_MESHS_DATA_INDICES);
  }
  int16_t start_frames() const {
    return GetField<int16_t>(VT_START_FRAMES, 0);
  }
  int16_t end_frames() const {
    return GetField<int16_t>(VT_END_FRAMES, 0);
  }
  int16_t total_frames() const {
    return GetField<int16_t>(VT_TOTAL_FRAMES, 0);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t labelNum() const {
    return GetField<int16_t>(VT_LABELNUM, 0);
  }
  int16_t canvas_size_w() const {
    return GetField<int16_t>(VT_CANVAS_SIZE_W, 0);
  }
  int16_t canvas_size_h() const {
    return GetField<int16_t>(VT_CANVAS_SIZE_H, 0);
  }
  float canvas_pvot_x() const {
    return GetField<float>(VT_CANVAS_PVOT_X, 0.0f);
  }
  float canvas_pvot_y() const {
    return GetField<float>(VT_CANVAS_PVOT_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DEFAULT_DATA) &&
           verifier.VerifyVector(default_data()) &&
           verifier.VerifyVectorOfTables(default_data()) &&
           VerifyOffset(verifier, VT_FRAME_DATA) &&
           verifier.VerifyVector(frame_data()) &&
           verifier.VerifyVectorOfTables(frame_data()) &&
           VerifyOffset(verifier, VT_USER_DATA) &&
           verifier.VerifyVector(user_data()) &&
           verifier.VerifyVectorOfTables(user_data()) &&
           VerifyOffset(verifier, VT_LABEL_DATA) &&
           verifier.VerifyVector(label_data()) &&
           verifier.VerifyVectorOfTables(label_data()) &&
           VerifyOffset(verifier, VT_MESHS_DATA_UV) &&
           verifier.VerifyVector(meshs_data_UV()) &&
           verifier.VerifyVectorOfTables(meshs_data_UV()) &&
           VerifyOffset(verifier, VT_MESHS_DATA_INDICES) &&
           verifier.VerifyVector(meshs_data_indices()) &&
           verifier.VerifyVectorOfTables(meshs_data_indices()) &&
           VerifyField<int16_t>(verifier, VT_START_FRAMES) &&
           VerifyField<int16_t>(verifier, VT_END_FRAMES) &&
           VerifyField<int16_t>(verifier, VT_TOTAL_FRAMES) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_LABELNUM) &&
           VerifyField<int16_t>(verifier, VT_CANVAS_SIZE_W) &&
           VerifyField<int16_t>(verifier, VT_CANVAS_SIZE_H) &&
           VerifyField<float>(verifier, VT_CANVAS_PVOT_X) &&
           VerifyField<float>(verifier, VT_CANVAS_PVOT_Y) &&
           verifier.EndTable();
  }
  AnimationDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimationDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimationData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimationDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationData::VT_NAME, name);
  }
  void add_default_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> default_data) {
    fbb_.AddOffset(AnimationData::VT_DEFAULT_DATA, default_data);
  }
  void add_frame_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FrameDataIndex>>> frame_data) {
    fbb_.AddOffset(AnimationData::VT_FRAME_DATA, frame_data);
  }
  void add_user_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserDataPerFrame>>> user_data) {
    fbb_.AddOffset(AnimationData::VT_USER_DATA, user_data);
  }
  void add_label_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LabelDataItem>>> label_data) {
    fbb_.AddOffset(AnimationData::VT_LABEL_DATA, label_data);
  }
  void add_meshs_data_UV(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshDataUV>>> meshs_data_UV) {
    fbb_.AddOffset(AnimationData::VT_MESHS_DATA_UV, meshs_data_UV);
  }
  void add_meshs_data_indices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshDataIndices>>> meshs_data_indices) {
    fbb_.AddOffset(AnimationData::VT_MESHS_DATA_INDICES, meshs_data_indices);
  }
  void add_start_frames(int16_t start_frames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_START_FRAMES, start_frames, 0);
  }
  void add_end_frames(int16_t end_frames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_END_FRAMES, end_frames, 0);
  }
  void add_total_frames(int16_t total_frames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_TOTAL_FRAMES, total_frames, 0);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(AnimationData::VT_FPS, fps, 0);
  }
  void add_labelNum(int16_t labelNum) {
    fbb_.AddElement<int16_t>(AnimationData::VT_LABELNUM, labelNum, 0);
  }
  void add_canvas_size_w(int16_t canvas_size_w) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVAS_SIZE_W, canvas_size_w, 0);
  }
  void add_canvas_size_h(int16_t canvas_size_h) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVAS_SIZE_H, canvas_size_h, 0);
  }
  void add_canvas_pvot_x(float canvas_pvot_x) {
    fbb_.AddElement<float>(AnimationData::VT_CANVAS_PVOT_X, canvas_pvot_x, 0.0f);
  }
  void add_canvas_pvot_y(float canvas_pvot_y) {
    fbb_.AddElement<float>(AnimationData::VT_CANVAS_PVOT_Y, canvas_pvot_y, 0.0f);
  }
  explicit AnimationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationDataBuilder &operator=(const AnimationDataBuilder &);
  flatbuffers::Offset<AnimationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationData> CreateAnimationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> default_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FrameDataIndex>>> frame_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserDataPerFrame>>> user_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LabelDataItem>>> label_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshDataUV>>> meshs_data_UV = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshDataIndices>>> meshs_data_indices = 0,
    int16_t start_frames = 0,
    int16_t end_frames = 0,
    int16_t total_frames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvas_size_w = 0,
    int16_t canvas_size_h = 0,
    float canvas_pvot_x = 0.0f,
    float canvas_pvot_y = 0.0f) {
  AnimationDataBuilder builder_(_fbb);
  builder_.add_canvas_pvot_y(canvas_pvot_y);
  builder_.add_canvas_pvot_x(canvas_pvot_x);
  builder_.add_meshs_data_indices(meshs_data_indices);
  builder_.add_meshs_data_UV(meshs_data_UV);
  builder_.add_label_data(label_data);
  builder_.add_user_data(user_data);
  builder_.add_frame_data(frame_data);
  builder_.add_default_data(default_data);
  builder_.add_name(name);
  builder_.add_canvas_size_h(canvas_size_h);
  builder_.add_canvas_size_w(canvas_size_w);
  builder_.add_labelNum(labelNum);
  builder_.add_fps(fps);
  builder_.add_total_frames(total_frames);
  builder_.add_end_frames(end_frames);
  builder_.add_start_frames(start_frames);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationData> CreateAnimationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<AnimationInitialData>> *default_data = nullptr,
    const std::vector<flatbuffers::Offset<FrameDataIndex>> *frame_data = nullptr,
    const std::vector<flatbuffers::Offset<UserDataPerFrame>> *user_data = nullptr,
    const std::vector<flatbuffers::Offset<LabelDataItem>> *label_data = nullptr,
    const std::vector<flatbuffers::Offset<MeshDataUV>> *meshs_data_UV = nullptr,
    const std::vector<flatbuffers::Offset<MeshDataIndices>> *meshs_data_indices = nullptr,
    int16_t start_frames = 0,
    int16_t end_frames = 0,
    int16_t total_frames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvas_size_w = 0,
    int16_t canvas_size_h = 0,
    float canvas_pvot_x = 0.0f,
    float canvas_pvot_y = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto default_data__ = default_data ? _fbb.CreateVector<flatbuffers::Offset<AnimationInitialData>>(*default_data) : 0;
  auto frame_data__ = frame_data ? _fbb.CreateVector<flatbuffers::Offset<FrameDataIndex>>(*frame_data) : 0;
  auto user_data__ = user_data ? _fbb.CreateVector<flatbuffers::Offset<UserDataPerFrame>>(*user_data) : 0;
  auto label_data__ = label_data ? _fbb.CreateVector<flatbuffers::Offset<LabelDataItem>>(*label_data) : 0;
  auto meshs_data_UV__ = meshs_data_UV ? _fbb.CreateVector<flatbuffers::Offset<MeshDataUV>>(*meshs_data_UV) : 0;
  auto meshs_data_indices__ = meshs_data_indices ? _fbb.CreateVector<flatbuffers::Offset<MeshDataIndices>>(*meshs_data_indices) : 0;
  return ss::ssfb::CreateAnimationData(
      _fbb,
      name__,
      default_data__,
      frame_data__,
      user_data__,
      label_data__,
      meshs_data_UV__,
      meshs_data_indices__,
      start_frames,
      end_frames,
      total_frames,
      fps,
      labelNum,
      canvas_size_w,
      canvas_size_h,
      canvas_pvot_x,
      canvas_pvot_y);
}

flatbuffers::Offset<AnimationData> CreateAnimationData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimationInitialDataT : public flatbuffers::NativeTable {
  typedef AnimationInitialData TableType;
  int16_t index;
  int32_t lowflag;
  int32_t highflag;
  int16_t priority;
  int16_t cell_index;
  int16_t opacity;
  int16_t local_opacity;
  int16_t masklimen;
  float position_x;
  float position_y;
  float position_z;
  float pivot_x;
  float pivot_y;
  float rotation_x;
  float rotation_y;
  float rotation_z;
  float scale_x;
  float scale_y;
  float local_scale_x;
  float local_scale_y;
  float size_x;
  float size_y;
  float uv_move_x;
  float uv_move_y;
  float uv_rotation;
  float uv_scale_x;
  float uv_scale_y;
  float bounding_radius;
  int32_t instance_value_cur_keyframe;
  int32_t instance_value_start_frame;
  int32_t instance_value_end_frame;
  int32_t instance_value_loop_num;
  float instance_value_speed;
  int32_t instance_value_loop_flag;
  int32_t effect_value_cur_keyframe;
  int32_t effect_value_start_time;
  float effect_value_speed;
  int32_t effect_value_loop_flag;
  AnimationInitialDataT()
      : index(0),
        lowflag(0),
        highflag(0),
        priority(0),
        cell_index(0),
        opacity(0),
        local_opacity(0),
        masklimen(0),
        position_x(0.0f),
        position_y(0.0f),
        position_z(0.0f),
        pivot_x(0.0f),
        pivot_y(0.0f),
        rotation_x(0.0f),
        rotation_y(0.0f),
        rotation_z(0.0f),
        scale_x(0.0f),
        scale_y(0.0f),
        local_scale_x(0.0f),
        local_scale_y(0.0f),
        size_x(0.0f),
        size_y(0.0f),
        uv_move_x(0.0f),
        uv_move_y(0.0f),
        uv_rotation(0.0f),
        uv_scale_x(0.0f),
        uv_scale_y(0.0f),
        bounding_radius(0.0f),
        instance_value_cur_keyframe(0),
        instance_value_start_frame(0),
        instance_value_end_frame(0),
        instance_value_loop_num(0),
        instance_value_speed(0.0f),
        instance_value_loop_flag(0),
        effect_value_cur_keyframe(0),
        effect_value_start_time(0),
        effect_value_speed(0.0f),
        effect_value_loop_flag(0) {
  }
};

inline bool operator==(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.lowflag == rhs.lowflag) &&
      (lhs.highflag == rhs.highflag) &&
      (lhs.priority == rhs.priority) &&
      (lhs.cell_index == rhs.cell_index) &&
      (lhs.opacity == rhs.opacity) &&
      (lhs.local_opacity == rhs.local_opacity) &&
      (lhs.masklimen == rhs.masklimen) &&
      (lhs.position_x == rhs.position_x) &&
      (lhs.position_y == rhs.position_y) &&
      (lhs.position_z == rhs.position_z) &&
      (lhs.pivot_x == rhs.pivot_x) &&
      (lhs.pivot_y == rhs.pivot_y) &&
      (lhs.rotation_x == rhs.rotation_x) &&
      (lhs.rotation_y == rhs.rotation_y) &&
      (lhs.rotation_z == rhs.rotation_z) &&
      (lhs.scale_x == rhs.scale_x) &&
      (lhs.scale_y == rhs.scale_y) &&
      (lhs.local_scale_x == rhs.local_scale_x) &&
      (lhs.local_scale_y == rhs.local_scale_y) &&
      (lhs.size_x == rhs.size_x) &&
      (lhs.size_y == rhs.size_y) &&
      (lhs.uv_move_x == rhs.uv_move_x) &&
      (lhs.uv_move_y == rhs.uv_move_y) &&
      (lhs.uv_rotation == rhs.uv_rotation) &&
      (lhs.uv_scale_x == rhs.uv_scale_x) &&
      (lhs.uv_scale_y == rhs.uv_scale_y) &&
      (lhs.bounding_radius == rhs.bounding_radius) &&
      (lhs.instance_value_cur_keyframe == rhs.instance_value_cur_keyframe) &&
      (lhs.instance_value_start_frame == rhs.instance_value_start_frame) &&
      (lhs.instance_value_end_frame == rhs.instance_value_end_frame) &&
      (lhs.instance_value_loop_num == rhs.instance_value_loop_num) &&
      (lhs.instance_value_speed == rhs.instance_value_speed) &&
      (lhs.instance_value_loop_flag == rhs.instance_value_loop_flag) &&
      (lhs.effect_value_cur_keyframe == rhs.effect_value_cur_keyframe) &&
      (lhs.effect_value_start_time == rhs.effect_value_start_time) &&
      (lhs.effect_value_speed == rhs.effect_value_speed) &&
      (lhs.effect_value_loop_flag == rhs.effect_value_loop_flag);
}

inline bool operator!=(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs) {
    return !(lhs == rhs);
}


struct AnimationInitialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationInitialDataT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_LOWFLAG = 6,
    VT_HIGHFLAG = 8,
    VT_PRIORITY = 10,
    VT_CELL_INDEX = 12,
    VT_OPACITY = 14,
    VT_LOCAL_OPACITY = 16,
    VT_MASKLIMEN = 18,
    VT_POSITION_X = 20,
    VT_POSITION_Y = 22,
    VT_POSITION_Z = 24,
    VT_PIVOT_X = 26,
    VT_PIVOT_Y = 28,
    VT_ROTATION_X = 30,
    VT_ROTATION_Y = 32,
    VT_ROTATION_Z = 34,
    VT_SCALE_X = 36,
    VT_SCALE_Y = 38,
    VT_LOCAL_SCALE_X = 40,
    VT_LOCAL_SCALE_Y = 42,
    VT_SIZE_X = 44,
    VT_SIZE_Y = 46,
    VT_UV_MOVE_X = 48,
    VT_UV_MOVE_Y = 50,
    VT_UV_ROTATION = 52,
    VT_UV_SCALE_X = 54,
    VT_UV_SCALE_Y = 56,
    VT_BOUNDING_RADIUS = 58,
    VT_INSTANCE_VALUE_CUR_KEYFRAME = 60,
    VT_INSTANCE_VALUE_START_FRAME = 62,
    VT_INSTANCE_VALUE_END_FRAME = 64,
    VT_INSTANCE_VALUE_LOOP_NUM = 66,
    VT_INSTANCE_VALUE_SPEED = 68,
    VT_INSTANCE_VALUE_LOOP_FLAG = 70,
    VT_EFFECT_VALUE_CUR_KEYFRAME = 72,
    VT_EFFECT_VALUE_START_TIME = 74,
    VT_EFFECT_VALUE_SPEED = 76,
    VT_EFFECT_VALUE_LOOP_FLAG = 78
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int32_t lowflag() const {
    return GetField<int32_t>(VT_LOWFLAG, 0);
  }
  int32_t highflag() const {
    return GetField<int32_t>(VT_HIGHFLAG, 0);
  }
  int16_t priority() const {
    return GetField<int16_t>(VT_PRIORITY, 0);
  }
  int16_t cell_index() const {
    return GetField<int16_t>(VT_CELL_INDEX, 0);
  }
  int16_t opacity() const {
    return GetField<int16_t>(VT_OPACITY, 0);
  }
  int16_t local_opacity() const {
    return GetField<int16_t>(VT_LOCAL_OPACITY, 0);
  }
  int16_t masklimen() const {
    return GetField<int16_t>(VT_MASKLIMEN, 0);
  }
  float position_x() const {
    return GetField<float>(VT_POSITION_X, 0.0f);
  }
  float position_y() const {
    return GetField<float>(VT_POSITION_Y, 0.0f);
  }
  float position_z() const {
    return GetField<float>(VT_POSITION_Z, 0.0f);
  }
  float pivot_x() const {
    return GetField<float>(VT_PIVOT_X, 0.0f);
  }
  float pivot_y() const {
    return GetField<float>(VT_PIVOT_Y, 0.0f);
  }
  float rotation_x() const {
    return GetField<float>(VT_ROTATION_X, 0.0f);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  float rotation_z() const {
    return GetField<float>(VT_ROTATION_Z, 0.0f);
  }
  float scale_x() const {
    return GetField<float>(VT_SCALE_X, 0.0f);
  }
  float scale_y() const {
    return GetField<float>(VT_SCALE_Y, 0.0f);
  }
  float local_scale_x() const {
    return GetField<float>(VT_LOCAL_SCALE_X, 0.0f);
  }
  float local_scale_y() const {
    return GetField<float>(VT_LOCAL_SCALE_Y, 0.0f);
  }
  float size_x() const {
    return GetField<float>(VT_SIZE_X, 0.0f);
  }
  float size_y() const {
    return GetField<float>(VT_SIZE_Y, 0.0f);
  }
  float uv_move_x() const {
    return GetField<float>(VT_UV_MOVE_X, 0.0f);
  }
  float uv_move_y() const {
    return GetField<float>(VT_UV_MOVE_Y, 0.0f);
  }
  float uv_rotation() const {
    return GetField<float>(VT_UV_ROTATION, 0.0f);
  }
  float uv_scale_x() const {
    return GetField<float>(VT_UV_SCALE_X, 0.0f);
  }
  float uv_scale_y() const {
    return GetField<float>(VT_UV_SCALE_Y, 0.0f);
  }
  float bounding_radius() const {
    return GetField<float>(VT_BOUNDING_RADIUS, 0.0f);
  }
  int32_t instance_value_cur_keyframe() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_CUR_KEYFRAME, 0);
  }
  int32_t instance_value_start_frame() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_START_FRAME, 0);
  }
  int32_t instance_value_end_frame() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_END_FRAME, 0);
  }
  int32_t instance_value_loop_num() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_LOOP_NUM, 0);
  }
  float instance_value_speed() const {
    return GetField<float>(VT_INSTANCE_VALUE_SPEED, 0.0f);
  }
  int32_t instance_value_loop_flag() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_LOOP_FLAG, 0);
  }
  int32_t effect_value_cur_keyframe() const {
    return GetField<int32_t>(VT_EFFECT_VALUE_CUR_KEYFRAME, 0);
  }
  int32_t effect_value_start_time() const {
    return GetField<int32_t>(VT_EFFECT_VALUE_START_TIME, 0);
  }
  float effect_value_speed() const {
    return GetField<float>(VT_EFFECT_VALUE_SPEED, 0.0f);
  }
  int32_t effect_value_loop_flag() const {
    return GetField<int32_t>(VT_EFFECT_VALUE_LOOP_FLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_LOWFLAG) &&
           VerifyField<int32_t>(verifier, VT_HIGHFLAG) &&
           VerifyField<int16_t>(verifier, VT_PRIORITY) &&
           VerifyField<int16_t>(verifier, VT_CELL_INDEX) &&
           VerifyField<int16_t>(verifier, VT_OPACITY) &&
           VerifyField<int16_t>(verifier, VT_LOCAL_OPACITY) &&
           VerifyField<int16_t>(verifier, VT_MASKLIMEN) &&
           VerifyField<float>(verifier, VT_POSITION_X) &&
           VerifyField<float>(verifier, VT_POSITION_Y) &&
           VerifyField<float>(verifier, VT_POSITION_Z) &&
           VerifyField<float>(verifier, VT_PIVOT_X) &&
           VerifyField<float>(verifier, VT_PIVOT_Y) &&
           VerifyField<float>(verifier, VT_ROTATION_X) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           VerifyField<float>(verifier, VT_ROTATION_Z) &&
           VerifyField<float>(verifier, VT_SCALE_X) &&
           VerifyField<float>(verifier, VT_SCALE_Y) &&
           VerifyField<float>(verifier, VT_LOCAL_SCALE_X) &&
           VerifyField<float>(verifier, VT_LOCAL_SCALE_Y) &&
           VerifyField<float>(verifier, VT_SIZE_X) &&
           VerifyField<float>(verifier, VT_SIZE_Y) &&
           VerifyField<float>(verifier, VT_UV_MOVE_X) &&
           VerifyField<float>(verifier, VT_UV_MOVE_Y) &&
           VerifyField<float>(verifier, VT_UV_ROTATION) &&
           VerifyField<float>(verifier, VT_UV_SCALE_X) &&
           VerifyField<float>(verifier, VT_UV_SCALE_Y) &&
           VerifyField<float>(verifier, VT_BOUNDING_RADIUS) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_CUR_KEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_START_FRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_END_FRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_LOOP_NUM) &&
           VerifyField<float>(verifier, VT_INSTANCE_VALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_LOOP_FLAG) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_VALUE_CUR_KEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_VALUE_START_TIME) &&
           VerifyField<float>(verifier, VT_EFFECT_VALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_VALUE_LOOP_FLAG) &&
           verifier.EndTable();
  }
  AnimationInitialDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimationInitialDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimationInitialData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimationInitialDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_INDEX, index, 0);
  }
  void add_lowflag(int32_t lowflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_LOWFLAG, lowflag, 0);
  }
  void add_highflag(int32_t highflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_HIGHFLAG, highflag, 0);
  }
  void add_priority(int16_t priority) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_PRIORITY, priority, 0);
  }
  void add_cell_index(int16_t cell_index) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_CELL_INDEX, cell_index, 0);
  }
  void add_opacity(int16_t opacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_OPACITY, opacity, 0);
  }
  void add_local_opacity(int16_t local_opacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_LOCAL_OPACITY, local_opacity, 0);
  }
  void add_masklimen(int16_t masklimen) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_MASKLIMEN, masklimen, 0);
  }
  void add_position_x(float position_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITION_X, position_x, 0.0f);
  }
  void add_position_y(float position_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITION_Y, position_y, 0.0f);
  }
  void add_position_z(float position_z) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITION_Z, position_z, 0.0f);
  }
  void add_pivot_x(float pivot_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOT_X, pivot_x, 0.0f);
  }
  void add_pivot_y(float pivot_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOT_Y, pivot_y, 0.0f);
  }
  void add_rotation_x(float rotation_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATION_X, rotation_x, 0.0f);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  void add_rotation_z(float rotation_z) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATION_Z, rotation_z, 0.0f);
  }
  void add_scale_x(float scale_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALE_X, scale_x, 0.0f);
  }
  void add_scale_y(float scale_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALE_Y, scale_y, 0.0f);
  }
  void add_local_scale_x(float local_scale_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCAL_SCALE_X, local_scale_x, 0.0f);
  }
  void add_local_scale_y(float local_scale_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCAL_SCALE_Y, local_scale_y, 0.0f);
  }
  void add_size_x(float size_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_X, size_x, 0.0f);
  }
  void add_size_y(float size_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_Y, size_y, 0.0f);
  }
  void add_uv_move_x(float uv_move_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_X, uv_move_x, 0.0f);
  }
  void add_uv_move_y(float uv_move_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_Y, uv_move_y, 0.0f);
  }
  void add_uv_rotation(float uv_rotation) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_ROTATION, uv_rotation, 0.0f);
  }
  void add_uv_scale_x(float uv_scale_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_X, uv_scale_x, 0.0f);
  }
  void add_uv_scale_y(float uv_scale_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_Y, uv_scale_y, 0.0f);
  }
  void add_bounding_radius(float bounding_radius) {
    fbb_.AddElement<float>(AnimationInitialData::VT_BOUNDING_RADIUS, bounding_radius, 0.0f);
  }
  void add_instance_value_cur_keyframe(int32_t instance_value_cur_keyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_CUR_KEYFRAME, instance_value_cur_keyframe, 0);
  }
  void add_instance_value_start_frame(int32_t instance_value_start_frame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_START_FRAME, instance_value_start_frame, 0);
  }
  void add_instance_value_end_frame(int32_t instance_value_end_frame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_END_FRAME, instance_value_end_frame, 0);
  }
  void add_instance_value_loop_num(int32_t instance_value_loop_num) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_LOOP_NUM, instance_value_loop_num, 0);
  }
  void add_instance_value_speed(float instance_value_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_INSTANCE_VALUE_SPEED, instance_value_speed, 0.0f);
  }
  void add_instance_value_loop_flag(int32_t instance_value_loop_flag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_LOOP_FLAG, instance_value_loop_flag, 0);
  }
  void add_effect_value_cur_keyframe(int32_t effect_value_cur_keyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECT_VALUE_CUR_KEYFRAME, effect_value_cur_keyframe, 0);
  }
  void add_effect_value_start_time(int32_t effect_value_start_time) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECT_VALUE_START_TIME, effect_value_start_time, 0);
  }
  void add_effect_value_speed(float effect_value_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_EFFECT_VALUE_SPEED, effect_value_speed, 0.0f);
  }
  void add_effect_value_loop_flag(int32_t effect_value_loop_flag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECT_VALUE_LOOP_FLAG, effect_value_loop_flag, 0);
  }
  explicit AnimationInitialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationInitialDataBuilder &operator=(const AnimationInitialDataBuilder &);
  flatbuffers::Offset<AnimationInitialData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationInitialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    int32_t lowflag = 0,
    int32_t highflag = 0,
    int16_t priority = 0,
    int16_t cell_index = 0,
    int16_t opacity = 0,
    int16_t local_opacity = 0,
    int16_t masklimen = 0,
    float position_x = 0.0f,
    float position_y = 0.0f,
    float position_z = 0.0f,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float rotation_x = 0.0f,
    float rotation_y = 0.0f,
    float rotation_z = 0.0f,
    float scale_x = 0.0f,
    float scale_y = 0.0f,
    float local_scale_x = 0.0f,
    float local_scale_y = 0.0f,
    float size_x = 0.0f,
    float size_y = 0.0f,
    float uv_move_x = 0.0f,
    float uv_move_y = 0.0f,
    float uv_rotation = 0.0f,
    float uv_scale_x = 0.0f,
    float uv_scale_y = 0.0f,
    float bounding_radius = 0.0f,
    int32_t instance_value_cur_keyframe = 0,
    int32_t instance_value_start_frame = 0,
    int32_t instance_value_end_frame = 0,
    int32_t instance_value_loop_num = 0,
    float instance_value_speed = 0.0f,
    int32_t instance_value_loop_flag = 0,
    int32_t effect_value_cur_keyframe = 0,
    int32_t effect_value_start_time = 0,
    float effect_value_speed = 0.0f,
    int32_t effect_value_loop_flag = 0) {
  AnimationInitialDataBuilder builder_(_fbb);
  builder_.add_effect_value_loop_flag(effect_value_loop_flag);
  builder_.add_effect_value_speed(effect_value_speed);
  builder_.add_effect_value_start_time(effect_value_start_time);
  builder_.add_effect_value_cur_keyframe(effect_value_cur_keyframe);
  builder_.add_instance_value_loop_flag(instance_value_loop_flag);
  builder_.add_instance_value_speed(instance_value_speed);
  builder_.add_instance_value_loop_num(instance_value_loop_num);
  builder_.add_instance_value_end_frame(instance_value_end_frame);
  builder_.add_instance_value_start_frame(instance_value_start_frame);
  builder_.add_instance_value_cur_keyframe(instance_value_cur_keyframe);
  builder_.add_bounding_radius(bounding_radius);
  builder_.add_uv_scale_y(uv_scale_y);
  builder_.add_uv_scale_x(uv_scale_x);
  builder_.add_uv_rotation(uv_rotation);
  builder_.add_uv_move_y(uv_move_y);
  builder_.add_uv_move_x(uv_move_x);
  builder_.add_size_y(size_y);
  builder_.add_size_x(size_x);
  builder_.add_local_scale_y(local_scale_y);
  builder_.add_local_scale_x(local_scale_x);
  builder_.add_scale_y(scale_y);
  builder_.add_scale_x(scale_x);
  builder_.add_rotation_z(rotation_z);
  builder_.add_rotation_y(rotation_y);
  builder_.add_rotation_x(rotation_x);
  builder_.add_pivot_y(pivot_y);
  builder_.add_pivot_x(pivot_x);
  builder_.add_position_z(position_z);
  builder_.add_position_y(position_y);
  builder_.add_position_x(position_x);
  builder_.add_highflag(highflag);
  builder_.add_lowflag(lowflag);
  builder_.add_masklimen(masklimen);
  builder_.add_local_opacity(local_opacity);
  builder_.add_opacity(opacity);
  builder_.add_cell_index(cell_index);
  builder_.add_priority(priority);
  builder_.add_index(index);
  return builder_.Finish();
}

flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartDataT : public flatbuffers::NativeTable {
  typedef PartData TableType;
  std::string name;
  int16_t index;
  int16_t parent_index;
  SsPartType type;
  int16_t bounds_type;
  int16_t alpha_blend_type;
  std::string refname;
  std::string effectfilename;
  std::string colorLabel;
  int16_t mask_influence;
  PartDataT()
      : index(0),
        parent_index(0),
        type(SsPartType_Nulltype),
        bounds_type(0),
        alpha_blend_type(0),
        mask_influence(0) {
  }
};

inline bool operator==(const PartDataT &lhs, const PartDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.index == rhs.index) &&
      (lhs.parent_index == rhs.parent_index) &&
      (lhs.type == rhs.type) &&
      (lhs.bounds_type == rhs.bounds_type) &&
      (lhs.alpha_blend_type == rhs.alpha_blend_type) &&
      (lhs.refname == rhs.refname) &&
      (lhs.effectfilename == rhs.effectfilename) &&
      (lhs.colorLabel == rhs.colorLabel) &&
      (lhs.mask_influence == rhs.mask_influence);
}

inline bool operator!=(const PartDataT &lhs, const PartDataT &rhs) {
    return !(lhs == rhs);
}


struct PartData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartDataT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INDEX = 6,
    VT_PARENT_INDEX = 8,
    VT_TYPE = 10,
    VT_BOUNDS_TYPE = 12,
    VT_ALPHA_BLEND_TYPE = 14,
    VT_REFNAME = 16,
    VT_EFFECTFILENAME = 18,
    VT_COLORLABEL = 20,
    VT_MASK_INFLUENCE = 22
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t parent_index() const {
    return GetField<int16_t>(VT_PARENT_INDEX, 0);
  }
  SsPartType type() const {
    return static_cast<SsPartType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int16_t bounds_type() const {
    return GetField<int16_t>(VT_BOUNDS_TYPE, 0);
  }
  int16_t alpha_blend_type() const {
    return GetField<int16_t>(VT_ALPHA_BLEND_TYPE, 0);
  }
  const flatbuffers::String *refname() const {
    return GetPointer<const flatbuffers::String *>(VT_REFNAME);
  }
  const flatbuffers::String *effectfilename() const {
    return GetPointer<const flatbuffers::String *>(VT_EFFECTFILENAME);
  }
  const flatbuffers::String *colorLabel() const {
    return GetPointer<const flatbuffers::String *>(VT_COLORLABEL);
  }
  int16_t mask_influence() const {
    return GetField<int16_t>(VT_MASK_INFLUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENT_INDEX) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_BOUNDS_TYPE) &&
           VerifyField<int16_t>(verifier, VT_ALPHA_BLEND_TYPE) &&
           VerifyOffset(verifier, VT_REFNAME) &&
           verifier.VerifyString(refname()) &&
           VerifyOffset(verifier, VT_EFFECTFILENAME) &&
           verifier.VerifyString(effectfilename()) &&
           VerifyOffset(verifier, VT_COLORLABEL) &&
           verifier.VerifyString(colorLabel()) &&
           VerifyField<int16_t>(verifier, VT_MASK_INFLUENCE) &&
           verifier.EndTable();
  }
  PartDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PartData::VT_NAME, name);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(PartData::VT_INDEX, index, 0);
  }
  void add_parent_index(int16_t parent_index) {
    fbb_.AddElement<int16_t>(PartData::VT_PARENT_INDEX, parent_index, 0);
  }
  void add_type(SsPartType type) {
    fbb_.AddElement<int8_t>(PartData::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_bounds_type(int16_t bounds_type) {
    fbb_.AddElement<int16_t>(PartData::VT_BOUNDS_TYPE, bounds_type, 0);
  }
  void add_alpha_blend_type(int16_t alpha_blend_type) {
    fbb_.AddElement<int16_t>(PartData::VT_ALPHA_BLEND_TYPE, alpha_blend_type, 0);
  }
  void add_refname(flatbuffers::Offset<flatbuffers::String> refname) {
    fbb_.AddOffset(PartData::VT_REFNAME, refname);
  }
  void add_effectfilename(flatbuffers::Offset<flatbuffers::String> effectfilename) {
    fbb_.AddOffset(PartData::VT_EFFECTFILENAME, effectfilename);
  }
  void add_colorLabel(flatbuffers::Offset<flatbuffers::String> colorLabel) {
    fbb_.AddOffset(PartData::VT_COLORLABEL, colorLabel);
  }
  void add_mask_influence(int16_t mask_influence) {
    fbb_.AddElement<int16_t>(PartData::VT_MASK_INFLUENCE, mask_influence, 0);
  }
  explicit PartDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartDataBuilder &operator=(const PartDataBuilder &);
  flatbuffers::Offset<PartData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartData> CreatePartData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t index = 0,
    int16_t parent_index = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t bounds_type = 0,
    int16_t alpha_blend_type = 0,
    flatbuffers::Offset<flatbuffers::String> refname = 0,
    flatbuffers::Offset<flatbuffers::String> effectfilename = 0,
    flatbuffers::Offset<flatbuffers::String> colorLabel = 0,
    int16_t mask_influence = 0) {
  PartDataBuilder builder_(_fbb);
  builder_.add_colorLabel(colorLabel);
  builder_.add_effectfilename(effectfilename);
  builder_.add_refname(refname);
  builder_.add_name(name);
  builder_.add_mask_influence(mask_influence);
  builder_.add_alpha_blend_type(alpha_blend_type);
  builder_.add_bounds_type(bounds_type);
  builder_.add_parent_index(parent_index);
  builder_.add_index(index);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartData> CreatePartDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t index = 0,
    int16_t parent_index = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t bounds_type = 0,
    int16_t alpha_blend_type = 0,
    const char *refname = nullptr,
    const char *effectfilename = nullptr,
    const char *colorLabel = nullptr,
    int16_t mask_influence = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto refname__ = refname ? _fbb.CreateString(refname) : 0;
  auto effectfilename__ = effectfilename ? _fbb.CreateString(effectfilename) : 0;
  auto colorLabel__ = colorLabel ? _fbb.CreateString(colorLabel) : 0;
  return ss::ssfb::CreatePartData(
      _fbb,
      name__,
      index,
      parent_index,
      type,
      bounds_type,
      alpha_blend_type,
      refname__,
      effectfilename__,
      colorLabel__,
      mask_influence);
}

flatbuffers::Offset<PartData> CreatePartData(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimePackDataT : public flatbuffers::NativeTable {
  typedef AnimePackData TableType;
  std::string name;
  std::vector<std::unique_ptr<PartDataT>> parts;
  std::vector<std::unique_ptr<AnimationDataT>> animations;
  AnimePackDataT() {
  }
};

inline bool operator==(const AnimePackDataT &lhs, const AnimePackDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.parts == rhs.parts) &&
      (lhs.animations == rhs.animations);
}

inline bool operator!=(const AnimePackDataT &lhs, const AnimePackDataT &rhs) {
    return !(lhs == rhs);
}


struct AnimePackData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimePackDataT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PARTS = 6,
    VT_ANIMATIONS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PartData>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PartData>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *>(VT_ANIMATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           verifier.EndTable();
  }
  AnimePackDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimePackDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimePackData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimePackDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimePackData::VT_NAME, name);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts) {
    fbb_.AddOffset(AnimePackData::VT_PARTS, parts);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations) {
    fbb_.AddOffset(AnimePackData::VT_ANIMATIONS, animations);
  }
  explicit AnimePackDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimePackDataBuilder &operator=(const AnimePackDataBuilder &);
  flatbuffers::Offset<AnimePackData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimePackData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations = 0) {
  AnimePackDataBuilder builder_(_fbb);
  builder_.add_animations(animations);
  builder_.add_parts(parts);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<PartData>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<AnimationData>> *animations = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto parts__ = parts ? _fbb.CreateVector<flatbuffers::Offset<PartData>>(*parts) : 0;
  auto animations__ = animations ? _fbb.CreateVector<flatbuffers::Offset<AnimationData>>(*animations) : 0;
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      name__,
      parts__,
      animations__);
}

flatbuffers::Offset<AnimePackData> CreateAnimePackData(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProjectDataT : public flatbuffers::NativeTable {
  typedef ProjectData TableType;
  uint32_t dataId;
  uint32_t version;
  int32_t flags;
  std::string image_base_dir;
  std::vector<std::unique_ptr<CellT>> cells;
  std::vector<std::unique_ptr<AnimePackDataT>> anime_packs;
  std::vector<std::unique_ptr<EffectFileT>> effect_file_list;
  int16_t num_cells;
  int16_t num_animePacks;
  int16_t num_effectFileList;
  ProjectDataT()
      : dataId(0),
        version(0),
        flags(0),
        num_cells(0),
        num_animePacks(0),
        num_effectFileList(0) {
  }
};

inline bool operator==(const ProjectDataT &lhs, const ProjectDataT &rhs) {
  return
      (lhs.dataId == rhs.dataId) &&
      (lhs.version == rhs.version) &&
      (lhs.flags == rhs.flags) &&
      (lhs.image_base_dir == rhs.image_base_dir) &&
      (lhs.cells == rhs.cells) &&
      (lhs.anime_packs == rhs.anime_packs) &&
      (lhs.effect_file_list == rhs.effect_file_list) &&
      (lhs.num_cells == rhs.num_cells) &&
      (lhs.num_animePacks == rhs.num_animePacks) &&
      (lhs.num_effectFileList == rhs.num_effectFileList);
}

inline bool operator!=(const ProjectDataT &lhs, const ProjectDataT &rhs) {
    return !(lhs == rhs);
}


struct ProjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectDataT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATAID = 4,
    VT_VERSION = 6,
    VT_FLAGS = 8,
    VT_IMAGE_BASE_DIR = 10,
    VT_CELLS = 12,
    VT_ANIME_PACKS = 14,
    VT_EFFECT_FILE_LIST = 16,
    VT_NUM_CELLS = 18,
    VT_NUM_ANIMEPACKS = 20,
    VT_NUM_EFFECTFILELIST = 22
  };
  uint32_t dataId() const {
    return GetField<uint32_t>(VT_DATAID, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  const flatbuffers::String *image_base_dir() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGE_BASE_DIR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Cell>> *cells() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Cell>> *>(VT_CELLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *anime_packs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *>(VT_ANIME_PACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *effect_file_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *>(VT_EFFECT_FILE_LIST);
  }
  int16_t num_cells() const {
    return GetField<int16_t>(VT_NUM_CELLS, 0);
  }
  int16_t num_animePacks() const {
    return GetField<int16_t>(VT_NUM_ANIMEPACKS, 0);
  }
  int16_t num_effectFileList() const {
    return GetField<int16_t>(VT_NUM_EFFECTFILELIST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DATAID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyOffset(verifier, VT_IMAGE_BASE_DIR) &&
           verifier.VerifyString(image_base_dir()) &&
           VerifyOffset(verifier, VT_CELLS) &&
           verifier.VerifyVector(cells()) &&
           verifier.VerifyVectorOfTables(cells()) &&
           VerifyOffset(verifier, VT_ANIME_PACKS) &&
           verifier.VerifyVector(anime_packs()) &&
           verifier.VerifyVectorOfTables(anime_packs()) &&
           VerifyOffset(verifier, VT_EFFECT_FILE_LIST) &&
           verifier.VerifyVector(effect_file_list()) &&
           verifier.VerifyVectorOfTables(effect_file_list()) &&
           VerifyField<int16_t>(verifier, VT_NUM_CELLS) &&
           VerifyField<int16_t>(verifier, VT_NUM_ANIMEPACKS) &&
           VerifyField<int16_t>(verifier, VT_NUM_EFFECTFILELIST) &&
           verifier.EndTable();
  }
  ProjectDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProjectDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProjectData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProjectDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataId(uint32_t dataId) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_DATAID, dataId, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_VERSION, version, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(ProjectData::VT_FLAGS, flags, 0);
  }
  void add_image_base_dir(flatbuffers::Offset<flatbuffers::String> image_base_dir) {
    fbb_.AddOffset(ProjectData::VT_IMAGE_BASE_DIR, image_base_dir);
  }
  void add_cells(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells) {
    fbb_.AddOffset(ProjectData::VT_CELLS, cells);
  }
  void add_anime_packs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> anime_packs) {
    fbb_.AddOffset(ProjectData::VT_ANIME_PACKS, anime_packs);
  }
  void add_effect_file_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effect_file_list) {
    fbb_.AddOffset(ProjectData::VT_EFFECT_FILE_LIST, effect_file_list);
  }
  void add_num_cells(int16_t num_cells) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUM_CELLS, num_cells, 0);
  }
  void add_num_animePacks(int16_t num_animePacks) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUM_ANIMEPACKS, num_animePacks, 0);
  }
  void add_num_effectFileList(int16_t num_effectFileList) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUM_EFFECTFILELIST, num_effectFileList, 0);
  }
  explicit ProjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectDataBuilder &operator=(const ProjectDataBuilder &);
  flatbuffers::Offset<ProjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectData> CreateProjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    int32_t flags = 0,
    flatbuffers::Offset<flatbuffers::String> image_base_dir = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> anime_packs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effect_file_list = 0,
    int16_t num_cells = 0,
    int16_t num_animePacks = 0,
    int16_t num_effectFileList = 0) {
  ProjectDataBuilder builder_(_fbb);
  builder_.add_effect_file_list(effect_file_list);
  builder_.add_anime_packs(anime_packs);
  builder_.add_cells(cells);
  builder_.add_image_base_dir(image_base_dir);
  builder_.add_flags(flags);
  builder_.add_version(version);
  builder_.add_dataId(dataId);
  builder_.add_num_effectFileList(num_effectFileList);
  builder_.add_num_animePacks(num_animePacks);
  builder_.add_num_cells(num_cells);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectData> CreateProjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    int32_t flags = 0,
    const char *image_base_dir = nullptr,
    const std::vector<flatbuffers::Offset<Cell>> *cells = nullptr,
    const std::vector<flatbuffers::Offset<AnimePackData>> *anime_packs = nullptr,
    const std::vector<flatbuffers::Offset<EffectFile>> *effect_file_list = nullptr,
    int16_t num_cells = 0,
    int16_t num_animePacks = 0,
    int16_t num_effectFileList = 0) {
  auto image_base_dir__ = image_base_dir ? _fbb.CreateString(image_base_dir) : 0;
  auto cells__ = cells ? _fbb.CreateVector<flatbuffers::Offset<Cell>>(*cells) : 0;
  auto anime_packs__ = anime_packs ? _fbb.CreateVector<flatbuffers::Offset<AnimePackData>>(*anime_packs) : 0;
  auto effect_file_list__ = effect_file_list ? _fbb.CreateVector<flatbuffers::Offset<EffectFile>>(*effect_file_list) : 0;
  return ss::ssfb::CreateProjectData(
      _fbb,
      dataId,
      version,
      flags,
      image_base_dir__,
      cells__,
      anime_packs__,
      effect_file_list__,
      num_cells,
      num_animePacks,
      num_effectFileList);
}

flatbuffers::Offset<ProjectData> CreateProjectData(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EffectNodeT *EffectNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EffectNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EffectNode::UnPackTo(EffectNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = array_index(); _o->array_index = _e; };
  { auto _e = parent_index(); _o->parent_index = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = cell_index(); _o->cell_index = _e; };
  { auto _e = blend_type(); _o->blend_type = _e; };
  { auto _e = num_behavior(); _o->num_behavior = _e; };
  { auto _e = behavior_type(); if (_e) { _o->behavior.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->behavior[_i].type = static_cast<EffectNodeBehavior>(_e->Get(_i)); } } };
  { auto _e = behavior(); if (_e) { _o->behavior.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->behavior[_i].value = EffectNodeBehaviorUnion::UnPack(_e->Get(_i), behavior_type()->GetEnum<EffectNodeBehavior>(_i), _resolver); } } };
}

inline flatbuffers::Offset<EffectNode> EffectNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEffectNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EffectNode> CreateEffectNode(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EffectNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _array_index = _o->array_index;
  auto _parent_index = _o->parent_index;
  auto _type = _o->type;
  auto _cell_index = _o->cell_index;
  auto _blend_type = _o->blend_type;
  auto _num_behavior = _o->num_behavior;
  auto _behavior_type = _o->behavior.size() ? _fbb.CreateVector<uint8_t>(_o->behavior.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->behavior[i].type); }, &_va) : 0;
  auto _behavior = _o->behavior.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->behavior.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->behavior[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return ss::ssfb::CreateEffectNode(
      _fbb,
      _array_index,
      _parent_index,
      _type,
      _cell_index,
      _blend_type,
      _num_behavior,
      _behavior_type,
      _behavior);
}

inline EffectFileT *EffectFile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EffectFileT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EffectFile::UnPackTo(EffectFileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = fps(); _o->fps = _e; };
  { auto _e = is_lock_rand_seed(); _o->is_lock_rand_seed = _e; };
  { auto _e = lock_rand_seed(); _o->lock_rand_seed = _e; };
  { auto _e = layout_scale_x(); _o->layout_scale_x = _e; };
  { auto _e = layout_scale_y(); _o->layout_scale_y = _e; };
  { auto _e = num_node_list(); _o->num_node_list = _e; };
  { auto _e = effect_node(); if (_e) { _o->effect_node.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->effect_node[_i] = std::unique_ptr<EffectNodeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<EffectFile> EffectFile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEffectFile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EffectFile> CreateEffectFile(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EffectFileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _fps = _o->fps;
  auto _is_lock_rand_seed = _o->is_lock_rand_seed;
  auto _lock_rand_seed = _o->lock_rand_seed;
  auto _layout_scale_x = _o->layout_scale_x;
  auto _layout_scale_y = _o->layout_scale_y;
  auto _num_node_list = _o->num_node_list;
  auto _effect_node = _o->effect_node.size() ? _fbb.CreateVector<flatbuffers::Offset<EffectNode>> (_o->effect_node.size(), [](size_t i, _VectorArgs *__va) { return CreateEffectNode(*__va->__fbb, __va->__o->effect_node[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateEffectFile(
      _fbb,
      _name,
      _fps,
      _is_lock_rand_seed,
      _lock_rand_seed,
      _layout_scale_x,
      _layout_scale_y,
      _num_node_list,
      _effect_node);
}

inline CellMapT *CellMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CellMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CellMap::UnPackTo(CellMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = image_path(); if (_e) _o->image_path = _e->str(); };
  { auto _e = index(); _o->index = _e; };
  { auto _e = wrap_mode(); _o->wrap_mode = _e; };
  { auto _e = filter_mode(); _o->filter_mode = _e; };
}

inline flatbuffers::Offset<CellMap> CellMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCellMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CellMap> CreateCellMap(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CellMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _image_path = _o->image_path.empty() ? 0 : _fbb.CreateString(_o->image_path);
  auto _index = _o->index;
  auto _wrap_mode = _o->wrap_mode;
  auto _filter_mode = _o->filter_mode;
  return ss::ssfb::CreateCellMap(
      _fbb,
      _name,
      _image_path,
      _index,
      _wrap_mode,
      _filter_mode);
}

inline CellT *Cell::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CellT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Cell::UnPackTo(CellT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = cell_map(); if (_e) _o->cell_map = std::unique_ptr<CellMapT>(_e->UnPack(_resolver)); };
  { auto _e = index_in_cell_map(); _o->index_in_cell_map = _e; };
  { auto _e = x(); _o->x = _e; };
  { auto _e = y(); _o->y = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = height(); _o->height = _e; };
  { auto _e = pivot_x(); _o->pivot_x = _e; };
  { auto _e = pivot_y(); _o->pivot_y = _e; };
  { auto _e = u1(); _o->u1 = _e; };
  { auto _e = v1(); _o->v1 = _e; };
  { auto _e = u2(); _o->u2 = _e; };
  { auto _e = v2(); _o->v2 = _e; };
}

inline flatbuffers::Offset<Cell> Cell::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCell(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cell> CreateCell(flatbuffers::FlatBufferBuilder &_fbb, const CellT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CellT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _cell_map = _o->cell_map ? CreateCellMap(_fbb, _o->cell_map.get(), _rehasher) : 0;
  auto _index_in_cell_map = _o->index_in_cell_map;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _pivot_x = _o->pivot_x;
  auto _pivot_y = _o->pivot_y;
  auto _u1 = _o->u1;
  auto _v1 = _o->v1;
  auto _u2 = _o->u2;
  auto _v2 = _o->v2;
  return ss::ssfb::CreateCell(
      _fbb,
      _name,
      _cell_map,
      _index_in_cell_map,
      _x,
      _y,
      _width,
      _height,
      _pivot_x,
      _pivot_y,
      _u1,
      _v1,
      _u2,
      _v2);
}

inline MeshDataUVT *MeshDataUV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MeshDataUVT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MeshDataUV::UnPackTo(MeshDataUVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uv(); if (_e) { _o->uv.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uv[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<MeshDataUV> MeshDataUV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeshDataUV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeshDataUV> CreateMeshDataUV(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshDataUVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uv = _o->uv.size() ? _fbb.CreateVector(_o->uv) : 0;
  return ss::ssfb::CreateMeshDataUV(
      _fbb,
      _uv);
}

inline MeshDataIndicesT *MeshDataIndices::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MeshDataIndicesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MeshDataIndices::UnPackTo(MeshDataIndicesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indices(); if (_e) { _o->indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indices[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<MeshDataIndices> MeshDataIndices::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeshDataIndices(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndices(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshDataIndicesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indices = _o->indices.size() ? _fbb.CreateVector(_o->indices) : 0;
  return ss::ssfb::CreateMeshDataIndices(
      _fbb,
      _indices);
}

inline PartStateT *PartState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PartStateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PartState::UnPackTo(PartStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; };
  { auto _e = flag1(); _o->flag1 = _e; };
  { auto _e = flag2(); _o->flag2 = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<PartState> PartState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartState> CreatePartState(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _flag1 = _o->flag1;
  auto _flag2 = _o->flag2;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return ss::ssfb::CreatePartState(
      _fbb,
      _index,
      _flag1,
      _flag2,
      _data);
}

inline FrameDataIndexT *FrameDataIndex::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FrameDataIndexT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FrameDataIndex::UnPackTo(FrameDataIndexT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = states(); if (_e) { _o->states.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->states[_i] = std::unique_ptr<PartStateT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<FrameDataIndex> FrameDataIndex::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameDataIndex(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndex(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameDataIndexT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _states = _o->states.size() ? _fbb.CreateVector<flatbuffers::Offset<PartState>> (_o->states.size(), [](size_t i, _VectorArgs *__va) { return CreatePartState(*__va->__fbb, __va->__o->states[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateFrameDataIndex(
      _fbb,
      _states);
}

inline UserDataStringT *UserDataString::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UserDataStringT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UserDataString::UnPackTo(UserDataStringT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = length(); _o->length = _e; };
  { auto _e = data(); if (_e) _o->data = _e->str(); };
}

inline flatbuffers::Offset<UserDataString> UserDataString::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataStringT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUserDataString(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserDataString> CreateUserDataString(flatbuffers::FlatBufferBuilder &_fbb, const UserDataStringT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UserDataStringT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _length = _o->length;
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  return ss::ssfb::CreateUserDataString(
      _fbb,
      _length,
      _data);
}

inline UserDataItemT *UserDataItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UserDataItemT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UserDataItem::UnPackTo(UserDataItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; };
  { auto _e = array_index(); _o->array_index = _e; };
  { auto _e = data_type(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i].type = static_cast<UserDataValue>(_e->Get(_i)); } } };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i].value = UserDataValueUnion::UnPack(_e->Get(_i), data_type()->GetEnum<UserDataValue>(_i), _resolver); } } };
}

inline flatbuffers::Offset<UserDataItem> UserDataItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUserDataItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserDataItem> CreateUserDataItem(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UserDataItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  auto _array_index = _o->array_index;
  auto _data_type = _o->data.size() ? _fbb.CreateVector<uint8_t>(_o->data.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->data[i].type); }, &_va) : 0;
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->data.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->data[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return ss::ssfb::CreateUserDataItem(
      _fbb,
      _flags,
      _array_index,
      _data_type,
      _data);
}

inline UserDataPerFrameT *UserDataPerFrame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UserDataPerFrameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UserDataPerFrame::UnPackTo(UserDataPerFrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame_index(); _o->frame_index = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = std::unique_ptr<UserDataItemT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<UserDataPerFrame> UserDataPerFrame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUserDataPerFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrame(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UserDataPerFrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame_index = _o->frame_index;
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<UserDataItem>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateUserDataItem(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateUserDataPerFrame(
      _fbb,
      _frame_index,
      _data);
}

inline LabelDataItemT *LabelDataItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LabelDataItemT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LabelDataItem::UnPackTo(LabelDataItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = label(); if (_e) _o->label = _e->str(); };
  { auto _e = frame_index(); _o->frame_index = _e; };
}

inline flatbuffers::Offset<LabelDataItem> LabelDataItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLabelDataItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LabelDataItem> CreateLabelDataItem(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LabelDataItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _label = _o->label.empty() ? 0 : _fbb.CreateString(_o->label);
  auto _frame_index = _o->frame_index;
  return ss::ssfb::CreateLabelDataItem(
      _fbb,
      _label,
      _frame_index);
}

inline AnimationDataT *AnimationData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AnimationDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AnimationData::UnPackTo(AnimationDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = default_data(); if (_e) { _o->default_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->default_data[_i] = std::unique_ptr<AnimationInitialDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = frame_data(); if (_e) { _o->frame_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frame_data[_i] = std::unique_ptr<FrameDataIndexT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = user_data(); if (_e) { _o->user_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->user_data[_i] = std::unique_ptr<UserDataPerFrameT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = label_data(); if (_e) { _o->label_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->label_data[_i] = std::unique_ptr<LabelDataItemT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = meshs_data_UV(); if (_e) { _o->meshs_data_UV.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meshs_data_UV[_i] = std::unique_ptr<MeshDataUVT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = meshs_data_indices(); if (_e) { _o->meshs_data_indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meshs_data_indices[_i] = std::unique_ptr<MeshDataIndicesT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = start_frames(); _o->start_frames = _e; };
  { auto _e = end_frames(); _o->end_frames = _e; };
  { auto _e = total_frames(); _o->total_frames = _e; };
  { auto _e = fps(); _o->fps = _e; };
  { auto _e = labelNum(); _o->labelNum = _e; };
  { auto _e = canvas_size_w(); _o->canvas_size_w = _e; };
  { auto _e = canvas_size_h(); _o->canvas_size_h = _e; };
  { auto _e = canvas_pvot_x(); _o->canvas_pvot_x = _e; };
  { auto _e = canvas_pvot_y(); _o->canvas_pvot_y = _e; };
}

inline flatbuffers::Offset<AnimationData> AnimationData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimationData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimationData> CreateAnimationData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimationDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _default_data = _o->default_data.size() ? _fbb.CreateVector<flatbuffers::Offset<AnimationInitialData>> (_o->default_data.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimationInitialData(*__va->__fbb, __va->__o->default_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _frame_data = _o->frame_data.size() ? _fbb.CreateVector<flatbuffers::Offset<FrameDataIndex>> (_o->frame_data.size(), [](size_t i, _VectorArgs *__va) { return CreateFrameDataIndex(*__va->__fbb, __va->__o->frame_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _user_data = _o->user_data.size() ? _fbb.CreateVector<flatbuffers::Offset<UserDataPerFrame>> (_o->user_data.size(), [](size_t i, _VectorArgs *__va) { return CreateUserDataPerFrame(*__va->__fbb, __va->__o->user_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _label_data = _o->label_data.size() ? _fbb.CreateVector<flatbuffers::Offset<LabelDataItem>> (_o->label_data.size(), [](size_t i, _VectorArgs *__va) { return CreateLabelDataItem(*__va->__fbb, __va->__o->label_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _meshs_data_UV = _o->meshs_data_UV.size() ? _fbb.CreateVector<flatbuffers::Offset<MeshDataUV>> (_o->meshs_data_UV.size(), [](size_t i, _VectorArgs *__va) { return CreateMeshDataUV(*__va->__fbb, __va->__o->meshs_data_UV[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _meshs_data_indices = _o->meshs_data_indices.size() ? _fbb.CreateVector<flatbuffers::Offset<MeshDataIndices>> (_o->meshs_data_indices.size(), [](size_t i, _VectorArgs *__va) { return CreateMeshDataIndices(*__va->__fbb, __va->__o->meshs_data_indices[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _start_frames = _o->start_frames;
  auto _end_frames = _o->end_frames;
  auto _total_frames = _o->total_frames;
  auto _fps = _o->fps;
  auto _labelNum = _o->labelNum;
  auto _canvas_size_w = _o->canvas_size_w;
  auto _canvas_size_h = _o->canvas_size_h;
  auto _canvas_pvot_x = _o->canvas_pvot_x;
  auto _canvas_pvot_y = _o->canvas_pvot_y;
  return ss::ssfb::CreateAnimationData(
      _fbb,
      _name,
      _default_data,
      _frame_data,
      _user_data,
      _label_data,
      _meshs_data_UV,
      _meshs_data_indices,
      _start_frames,
      _end_frames,
      _total_frames,
      _fps,
      _labelNum,
      _canvas_size_w,
      _canvas_size_h,
      _canvas_pvot_x,
      _canvas_pvot_y);
}

inline AnimationInitialDataT *AnimationInitialData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AnimationInitialDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AnimationInitialData::UnPackTo(AnimationInitialDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; };
  { auto _e = lowflag(); _o->lowflag = _e; };
  { auto _e = highflag(); _o->highflag = _e; };
  { auto _e = priority(); _o->priority = _e; };
  { auto _e = cell_index(); _o->cell_index = _e; };
  { auto _e = opacity(); _o->opacity = _e; };
  { auto _e = local_opacity(); _o->local_opacity = _e; };
  { auto _e = masklimen(); _o->masklimen = _e; };
  { auto _e = position_x(); _o->position_x = _e; };
  { auto _e = position_y(); _o->position_y = _e; };
  { auto _e = position_z(); _o->position_z = _e; };
  { auto _e = pivot_x(); _o->pivot_x = _e; };
  { auto _e = pivot_y(); _o->pivot_y = _e; };
  { auto _e = rotation_x(); _o->rotation_x = _e; };
  { auto _e = rotation_y(); _o->rotation_y = _e; };
  { auto _e = rotation_z(); _o->rotation_z = _e; };
  { auto _e = scale_x(); _o->scale_x = _e; };
  { auto _e = scale_y(); _o->scale_y = _e; };
  { auto _e = local_scale_x(); _o->local_scale_x = _e; };
  { auto _e = local_scale_y(); _o->local_scale_y = _e; };
  { auto _e = size_x(); _o->size_x = _e; };
  { auto _e = size_y(); _o->size_y = _e; };
  { auto _e = uv_move_x(); _o->uv_move_x = _e; };
  { auto _e = uv_move_y(); _o->uv_move_y = _e; };
  { auto _e = uv_rotation(); _o->uv_rotation = _e; };
  { auto _e = uv_scale_x(); _o->uv_scale_x = _e; };
  { auto _e = uv_scale_y(); _o->uv_scale_y = _e; };
  { auto _e = bounding_radius(); _o->bounding_radius = _e; };
  { auto _e = instance_value_cur_keyframe(); _o->instance_value_cur_keyframe = _e; };
  { auto _e = instance_value_start_frame(); _o->instance_value_start_frame = _e; };
  { auto _e = instance_value_end_frame(); _o->instance_value_end_frame = _e; };
  { auto _e = instance_value_loop_num(); _o->instance_value_loop_num = _e; };
  { auto _e = instance_value_speed(); _o->instance_value_speed = _e; };
  { auto _e = instance_value_loop_flag(); _o->instance_value_loop_flag = _e; };
  { auto _e = effect_value_cur_keyframe(); _o->effect_value_cur_keyframe = _e; };
  { auto _e = effect_value_start_time(); _o->effect_value_start_time = _e; };
  { auto _e = effect_value_speed(); _o->effect_value_speed = _e; };
  { auto _e = effect_value_loop_flag(); _o->effect_value_loop_flag = _e; };
}

inline flatbuffers::Offset<AnimationInitialData> AnimationInitialData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimationInitialData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimationInitialDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _lowflag = _o->lowflag;
  auto _highflag = _o->highflag;
  auto _priority = _o->priority;
  auto _cell_index = _o->cell_index;
  auto _opacity = _o->opacity;
  auto _local_opacity = _o->local_opacity;
  auto _masklimen = _o->masklimen;
  auto _position_x = _o->position_x;
  auto _position_y = _o->position_y;
  auto _position_z = _o->position_z;
  auto _pivot_x = _o->pivot_x;
  auto _pivot_y = _o->pivot_y;
  auto _rotation_x = _o->rotation_x;
  auto _rotation_y = _o->rotation_y;
  auto _rotation_z = _o->rotation_z;
  auto _scale_x = _o->scale_x;
  auto _scale_y = _o->scale_y;
  auto _local_scale_x = _o->local_scale_x;
  auto _local_scale_y = _o->local_scale_y;
  auto _size_x = _o->size_x;
  auto _size_y = _o->size_y;
  auto _uv_move_x = _o->uv_move_x;
  auto _uv_move_y = _o->uv_move_y;
  auto _uv_rotation = _o->uv_rotation;
  auto _uv_scale_x = _o->uv_scale_x;
  auto _uv_scale_y = _o->uv_scale_y;
  auto _bounding_radius = _o->bounding_radius;
  auto _instance_value_cur_keyframe = _o->instance_value_cur_keyframe;
  auto _instance_value_start_frame = _o->instance_value_start_frame;
  auto _instance_value_end_frame = _o->instance_value_end_frame;
  auto _instance_value_loop_num = _o->instance_value_loop_num;
  auto _instance_value_speed = _o->instance_value_speed;
  auto _instance_value_loop_flag = _o->instance_value_loop_flag;
  auto _effect_value_cur_keyframe = _o->effect_value_cur_keyframe;
  auto _effect_value_start_time = _o->effect_value_start_time;
  auto _effect_value_speed = _o->effect_value_speed;
  auto _effect_value_loop_flag = _o->effect_value_loop_flag;
  return ss::ssfb::CreateAnimationInitialData(
      _fbb,
      _index,
      _lowflag,
      _highflag,
      _priority,
      _cell_index,
      _opacity,
      _local_opacity,
      _masklimen,
      _position_x,
      _position_y,
      _position_z,
      _pivot_x,
      _pivot_y,
      _rotation_x,
      _rotation_y,
      _rotation_z,
      _scale_x,
      _scale_y,
      _local_scale_x,
      _local_scale_y,
      _size_x,
      _size_y,
      _uv_move_x,
      _uv_move_y,
      _uv_rotation,
      _uv_scale_x,
      _uv_scale_y,
      _bounding_radius,
      _instance_value_cur_keyframe,
      _instance_value_start_frame,
      _instance_value_end_frame,
      _instance_value_loop_num,
      _instance_value_speed,
      _instance_value_loop_flag,
      _effect_value_cur_keyframe,
      _effect_value_start_time,
      _effect_value_speed,
      _effect_value_loop_flag);
}

inline PartDataT *PartData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PartDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PartData::UnPackTo(PartDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = index(); _o->index = _e; };
  { auto _e = parent_index(); _o->parent_index = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = bounds_type(); _o->bounds_type = _e; };
  { auto _e = alpha_blend_type(); _o->alpha_blend_type = _e; };
  { auto _e = refname(); if (_e) _o->refname = _e->str(); };
  { auto _e = effectfilename(); if (_e) _o->effectfilename = _e->str(); };
  { auto _e = colorLabel(); if (_e) _o->colorLabel = _e->str(); };
  { auto _e = mask_influence(); _o->mask_influence = _e; };
}

inline flatbuffers::Offset<PartData> PartData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartData> CreatePartData(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _index = _o->index;
  auto _parent_index = _o->parent_index;
  auto _type = _o->type;
  auto _bounds_type = _o->bounds_type;
  auto _alpha_blend_type = _o->alpha_blend_type;
  auto _refname = _o->refname.empty() ? 0 : _fbb.CreateString(_o->refname);
  auto _effectfilename = _o->effectfilename.empty() ? 0 : _fbb.CreateString(_o->effectfilename);
  auto _colorLabel = _o->colorLabel.empty() ? 0 : _fbb.CreateString(_o->colorLabel);
  auto _mask_influence = _o->mask_influence;
  return ss::ssfb::CreatePartData(
      _fbb,
      _name,
      _index,
      _parent_index,
      _type,
      _bounds_type,
      _alpha_blend_type,
      _refname,
      _effectfilename,
      _colorLabel,
      _mask_influence);
}

inline AnimePackDataT *AnimePackData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AnimePackDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AnimePackData::UnPackTo(AnimePackDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = parts(); if (_e) { _o->parts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parts[_i] = std::unique_ptr<PartDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = animations(); if (_e) { _o->animations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->animations[_i] = std::unique_ptr<AnimationDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AnimePackData> AnimePackData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimePackData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimePackDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _parts = _o->parts.size() ? _fbb.CreateVector<flatbuffers::Offset<PartData>> (_o->parts.size(), [](size_t i, _VectorArgs *__va) { return CreatePartData(*__va->__fbb, __va->__o->parts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _animations = _o->animations.size() ? _fbb.CreateVector<flatbuffers::Offset<AnimationData>> (_o->animations.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimationData(*__va->__fbb, __va->__o->animations[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      _name,
      _parts,
      _animations);
}

inline ProjectDataT *ProjectData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProjectDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProjectData::UnPackTo(ProjectDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dataId(); _o->dataId = _e; };
  { auto _e = version(); _o->version = _e; };
  { auto _e = flags(); _o->flags = _e; };
  { auto _e = image_base_dir(); if (_e) _o->image_base_dir = _e->str(); };
  { auto _e = cells(); if (_e) { _o->cells.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cells[_i] = std::unique_ptr<CellT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = anime_packs(); if (_e) { _o->anime_packs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->anime_packs[_i] = std::unique_ptr<AnimePackDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = effect_file_list(); if (_e) { _o->effect_file_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->effect_file_list[_i] = std::unique_ptr<EffectFileT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = num_cells(); _o->num_cells = _e; };
  { auto _e = num_animePacks(); _o->num_animePacks = _e; };
  { auto _e = num_effectFileList(); _o->num_effectFileList = _e; };
}

inline flatbuffers::Offset<ProjectData> ProjectData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProjectData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProjectData> CreateProjectData(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProjectDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dataId = _o->dataId;
  auto _version = _o->version;
  auto _flags = _o->flags;
  auto _image_base_dir = _o->image_base_dir.empty() ? 0 : _fbb.CreateString(_o->image_base_dir);
  auto _cells = _o->cells.size() ? _fbb.CreateVector<flatbuffers::Offset<Cell>> (_o->cells.size(), [](size_t i, _VectorArgs *__va) { return CreateCell(*__va->__fbb, __va->__o->cells[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _anime_packs = _o->anime_packs.size() ? _fbb.CreateVector<flatbuffers::Offset<AnimePackData>> (_o->anime_packs.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimePackData(*__va->__fbb, __va->__o->anime_packs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _effect_file_list = _o->effect_file_list.size() ? _fbb.CreateVector<flatbuffers::Offset<EffectFile>> (_o->effect_file_list.size(), [](size_t i, _VectorArgs *__va) { return CreateEffectFile(*__va->__fbb, __va->__o->effect_file_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _num_cells = _o->num_cells;
  auto _num_animePacks = _o->num_animePacks;
  auto _num_effectFileList = _o->num_effectFileList;
  return ss::ssfb::CreateProjectData(
      _fbb,
      _dataId,
      _version,
      _flags,
      _image_base_dir,
      _cells,
      _anime_packs,
      _effect_file_list,
      _num_cells,
      _num_animePacks,
      _num_effectFileList);
}

inline bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type) {
  switch (type) {
    case EffectNodeBehavior_NONE: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementBasic: {
      return verifier.Verify<EffectParticleElementBasic>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      return verifier.Verify<EffectParticleElementRndSeedChange>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      return verifier.Verify<EffectParticleElementDelay>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      return verifier.Verify<EffectParticleElementGravity>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      return verifier.Verify<EffectParticleElementPosition>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      return verifier.Verify<EffectParticleElementRotation>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      return verifier.Verify<EffectParticleElementRotationTrans>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      return verifier.Verify<EffectParticleElementTransSpeed>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      return verifier.Verify<EffectParticleElementTangentialAcceleration>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      return verifier.Verify<EffectParticleElementInitColor>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      return verifier.Verify<EffectParticleElementTransColor>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      return verifier.Verify<EffectParticleElementAlphaFade>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      return verifier.Verify<EffectParticleElementSize>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      return verifier.Verify<EffectParticleElementTransSize>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      return verifier.Verify<EffectParticlePointGravity>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      return verifier.Verify<EffectParticleTurnToDirectionEnabled>(static_cast<const uint8_t *>(obj), 0);
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      return verifier.Verify<EffectParticleInfiniteEmitEnabled>(static_cast<const uint8_t *>(obj), 0);
    }
    default: return false;
  }
}

inline bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEffectNodeBehavior(
        verifier,  values->Get(i), types->GetEnum<EffectNodeBehavior>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EffectNodeBehaviorUnion::UnPack(const void *obj, EffectNodeBehavior type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      auto ptr = reinterpret_cast<const EffectParticleElementBasic *>(obj);
      return new EffectParticleElementBasic(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      auto ptr = reinterpret_cast<const EffectParticleElementRndSeedChange *>(obj);
      return new EffectParticleElementRndSeedChange(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      auto ptr = reinterpret_cast<const EffectParticleElementDelay *>(obj);
      return new EffectParticleElementDelay(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      auto ptr = reinterpret_cast<const EffectParticleElementGravity *>(obj);
      return new EffectParticleElementGravity(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      auto ptr = reinterpret_cast<const EffectParticleElementPosition *>(obj);
      return new EffectParticleElementPosition(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotation *>(obj);
      return new EffectParticleElementRotation(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotationTrans *>(obj);
      return new EffectParticleElementRotationTrans(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSpeed *>(obj);
      return new EffectParticleElementTransSpeed(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      auto ptr = reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(obj);
      return new EffectParticleElementTangentialAcceleration(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementInitColor *>(obj);
      return new EffectParticleElementInitColor(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransColor *>(obj);
      return new EffectParticleElementTransColor(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      auto ptr = reinterpret_cast<const EffectParticleElementAlphaFade *>(obj);
      return new EffectParticleElementAlphaFade(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementSize *>(obj);
      return new EffectParticleElementSize(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSize *>(obj);
      return new EffectParticleElementTransSize(*ptr);
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      auto ptr = reinterpret_cast<const EffectParticlePointGravity *>(obj);
      return new EffectParticlePointGravity(*ptr);
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(obj);
      return new EffectParticleTurnToDirectionEnabled(*ptr);
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(obj);
      return new EffectParticleInfiniteEmitEnabled(*ptr);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> EffectNodeBehaviorUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      auto ptr = reinterpret_cast<const EffectParticleElementBasic *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      auto ptr = reinterpret_cast<const EffectParticleElementRndSeedChange *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      auto ptr = reinterpret_cast<const EffectParticleElementDelay *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      auto ptr = reinterpret_cast<const EffectParticleElementGravity *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      auto ptr = reinterpret_cast<const EffectParticleElementPosition *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotation *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotationTrans *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSpeed *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      auto ptr = reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementInitColor *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransColor *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      auto ptr = reinterpret_cast<const EffectParticleElementAlphaFade *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementSize *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSize *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      auto ptr = reinterpret_cast<const EffectParticlePointGravity *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    default: return 0;
  }
}

inline EffectNodeBehaviorUnion::EffectNodeBehaviorUnion(const EffectNodeBehaviorUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      value = new EffectParticleElementBasic(*reinterpret_cast<EffectParticleElementBasic *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      value = new EffectParticleElementRndSeedChange(*reinterpret_cast<EffectParticleElementRndSeedChange *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      value = new EffectParticleElementDelay(*reinterpret_cast<EffectParticleElementDelay *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      value = new EffectParticleElementGravity(*reinterpret_cast<EffectParticleElementGravity *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      value = new EffectParticleElementPosition(*reinterpret_cast<EffectParticleElementPosition *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      value = new EffectParticleElementRotation(*reinterpret_cast<EffectParticleElementRotation *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      value = new EffectParticleElementRotationTrans(*reinterpret_cast<EffectParticleElementRotationTrans *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      value = new EffectParticleElementTransSpeed(*reinterpret_cast<EffectParticleElementTransSpeed *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      value = new EffectParticleElementTangentialAcceleration(*reinterpret_cast<EffectParticleElementTangentialAcceleration *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      value = new EffectParticleElementInitColor(*reinterpret_cast<EffectParticleElementInitColor *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      value = new EffectParticleElementTransColor(*reinterpret_cast<EffectParticleElementTransColor *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      value = new EffectParticleElementAlphaFade(*reinterpret_cast<EffectParticleElementAlphaFade *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      value = new EffectParticleElementSize(*reinterpret_cast<EffectParticleElementSize *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      value = new EffectParticleElementTransSize(*reinterpret_cast<EffectParticleElementTransSize *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      value = new EffectParticlePointGravity(*reinterpret_cast<EffectParticlePointGravity *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      value = new EffectParticleTurnToDirectionEnabled(*reinterpret_cast<EffectParticleTurnToDirectionEnabled *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      value = new EffectParticleInfiniteEmitEnabled(*reinterpret_cast<EffectParticleInfiniteEmitEnabled *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EffectNodeBehaviorUnion::Reset() {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      auto ptr = reinterpret_cast<EffectParticleElementBasic *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      auto ptr = reinterpret_cast<EffectParticleElementRndSeedChange *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      auto ptr = reinterpret_cast<EffectParticleElementDelay *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      auto ptr = reinterpret_cast<EffectParticleElementGravity *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      auto ptr = reinterpret_cast<EffectParticleElementPosition *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      auto ptr = reinterpret_cast<EffectParticleElementRotation *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      auto ptr = reinterpret_cast<EffectParticleElementRotationTrans *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      auto ptr = reinterpret_cast<EffectParticleElementTransSpeed *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      auto ptr = reinterpret_cast<EffectParticleElementTangentialAcceleration *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      auto ptr = reinterpret_cast<EffectParticleElementInitColor *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      auto ptr = reinterpret_cast<EffectParticleElementTransColor *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      auto ptr = reinterpret_cast<EffectParticleElementAlphaFade *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      auto ptr = reinterpret_cast<EffectParticleElementSize *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      auto ptr = reinterpret_cast<EffectParticleElementTransSize *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      auto ptr = reinterpret_cast<EffectParticlePointGravity *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      auto ptr = reinterpret_cast<EffectParticleTurnToDirectionEnabled *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      auto ptr = reinterpret_cast<EffectParticleInfiniteEmitEnabled *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = EffectNodeBehavior_NONE;
}

inline bool VerifyUserDataValue(flatbuffers::Verifier &verifier, const void *obj, UserDataValue type) {
  switch (type) {
    case UserDataValue_NONE: {
      return true;
    }
    case UserDataValue_UserDataInteger: {
      return verifier.Verify<UserDataInteger>(static_cast<const uint8_t *>(obj), 0);
    }
    case UserDataValue_UserDataRect: {
      return verifier.Verify<UserDataRect>(static_cast<const uint8_t *>(obj), 0);
    }
    case UserDataValue_UserDataPoint: {
      return verifier.Verify<UserDataPoint>(static_cast<const uint8_t *>(obj), 0);
    }
    case UserDataValue_UserDataString: {
      auto ptr = reinterpret_cast<const UserDataString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyUserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserDataValue(
        verifier,  values->Get(i), types->GetEnum<UserDataValue>(i))) {
      return false;
    }
  }
  return true;
}

inline void *UserDataValueUnion::UnPack(const void *obj, UserDataValue type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case UserDataValue_UserDataInteger: {
      auto ptr = reinterpret_cast<const UserDataInteger *>(obj);
      return new UserDataInteger(*ptr);
    }
    case UserDataValue_UserDataRect: {
      auto ptr = reinterpret_cast<const UserDataRect *>(obj);
      return new UserDataRect(*ptr);
    }
    case UserDataValue_UserDataPoint: {
      auto ptr = reinterpret_cast<const UserDataPoint *>(obj);
      return new UserDataPoint(*ptr);
    }
    case UserDataValue_UserDataString: {
      auto ptr = reinterpret_cast<const UserDataString *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> UserDataValueUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case UserDataValue_UserDataInteger: {
      auto ptr = reinterpret_cast<const UserDataInteger *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case UserDataValue_UserDataRect: {
      auto ptr = reinterpret_cast<const UserDataRect *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case UserDataValue_UserDataPoint: {
      auto ptr = reinterpret_cast<const UserDataPoint *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case UserDataValue_UserDataString: {
      auto ptr = reinterpret_cast<const UserDataStringT *>(value);
      return CreateUserDataString(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline UserDataValueUnion::UserDataValueUnion(const UserDataValueUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case UserDataValue_UserDataInteger: {
      value = new UserDataInteger(*reinterpret_cast<UserDataInteger *>(u.value));
      break;
    }
    case UserDataValue_UserDataRect: {
      value = new UserDataRect(*reinterpret_cast<UserDataRect *>(u.value));
      break;
    }
    case UserDataValue_UserDataPoint: {
      value = new UserDataPoint(*reinterpret_cast<UserDataPoint *>(u.value));
      break;
    }
    case UserDataValue_UserDataString: {
      value = new UserDataStringT(*reinterpret_cast<UserDataStringT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void UserDataValueUnion::Reset() {
  switch (type) {
    case UserDataValue_UserDataInteger: {
      auto ptr = reinterpret_cast<UserDataInteger *>(value);
      delete ptr;
      break;
    }
    case UserDataValue_UserDataRect: {
      auto ptr = reinterpret_cast<UserDataRect *>(value);
      delete ptr;
      break;
    }
    case UserDataValue_UserDataPoint: {
      auto ptr = reinterpret_cast<UserDataPoint *>(value);
      delete ptr;
      break;
    }
    case UserDataValue_UserDataString: {
      auto ptr = reinterpret_cast<UserDataStringT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = UserDataValue_NONE;
}

inline const ss::ssfb::ProjectData *GetProjectData(const void *buf) {
  return flatbuffers::GetRoot<ss::ssfb::ProjectData>(buf);
}

inline const ss::ssfb::ProjectData *GetSizePrefixedProjectData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ss::ssfb::ProjectData>(buf);
}

inline const char *ProjectDataIdentifier() {
  return "SSFB";
}

inline bool ProjectDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProjectDataIdentifier());
}

inline bool VerifyProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline bool VerifySizePrefixedProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline void FinishProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.Finish(root, ProjectDataIdentifier());
}

inline void FinishSizePrefixedProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.FinishSizePrefixed(root, ProjectDataIdentifier());
}

inline std::unique_ptr<ProjectDataT> UnPackProjectData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ProjectDataT>(GetProjectData(buf)->UnPack(res));
}

}  // namespace ssfb
}  // namespace ss

#endif  // FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
